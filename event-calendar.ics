BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//researchr.org//conf.researchr.org//EN
CALSCALE:GREGORIAN

BEGIN:VEVENT
DTSTART:20200119T090000Z
DTEND:20200119T093000Z
DTSTAMP:20191226T230629Z
UID:3038856c-a4d6-44bf-94f6-f8b708e2d503@conf.researchr.org
CREATED:20191202T185113Z
SUMMARY:[PLanQC] Invited Talk - Jennifer Paykin - Jennifer Paykin
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T041725Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T093000Z
DTEND:20200119T100000Z
DTSTAMP:20191226T230629Z
UID:ee7ba18d-0983-4c70-ad86-f8ab1ac7f3ac@conf.researchr.org
CREATED:20191202T185113Z
SUMMARY:[PLanQC] Invited Talk - Peter Selinger - Peter Selinger
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191202T185113Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T090000Z
DTEND:20200119T100000Z
DTSTAMP:20191226T230629Z
UID:b772090b-b34c-4cf7-9dd7-5f13753cd920@conf.researchr.org
CREATED:20191205T235928Z
SUMMARY:[VMCAI] Safety and Robustness for Deep Learning with Provable Guarantees - Marta Kwiatkowska
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T100000Z
DTEND:20200119T103000Z
DTSTAMP:20191226T230629Z
UID:76bd5054-64c0-4537-bf50-eed3f9bf2967@conf.researchr.org
CREATED:20191210T160725Z
SUMMARY:[POPL Catering] Break
DESCRIPTION:Break
LOCATION:Break -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191210T161021Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T103000Z
DTEND:20200119T110000Z
DTSTAMP:20191226T230629Z
UID:86c47292-956a-4cbb-8ff4-f92dd77285bd@conf.researchr.org
CREATED:20191202T190757Z
SUMMARY:[PLanQC] Invited Talk - Bettina Heim - Bettina Heim
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T225514Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T110000Z
DTEND:20200119T113000Z
DTSTAMP:20191226T230629Z
UID:c8319db2-2ff3-4c17-af19-3bdce2f4a4b5@conf.researchr.org
CREATED:20191202T190757Z
SUMMARY:[PLanQC] Invited Talk: Resource-Efficient Quantum Computing by Breaking Abstractions - Fred Chong
DESCRIPTION:Quantum computing is at an inflection point\, where 53-qubit (quantum bit) machines are deployed\, 100-qubit machines are just around the corner\, and even 1000-qubit machines are perhaps only a few years away. These machines have the potential to fundamentally change our concept of what is computable and demonstrate practical applications in areas such as quantum chemistry\, optimization\, and quantum simulation. \nYet a significant resource gap remains between practical quantum algorithms and real machines. A promising approach to closing this gap is to selectively expose to programming languages and compilers some of the key physical properties of emerging quantum technologies. I will describe some of our recent work that focuses on compilation techniques that break traditional abstractions\, including compiling directly to analog control pulses\, compiling for machine variations\, and compiling with ternary quantum bits. I will also describe other important verification challenges to be solved on the road to practical quantum computing.
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T180308Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T113000Z
DTEND:20200119T115000Z
DTSTAMP:20191226T230629Z
UID:d5401feb-a0e2-43d8-8b8a-f1aa427b288e@conf.researchr.org
CREATED:20191202T190757Z
SUMMARY:[PLanQC] Tuning up entanglement through the cloud using Qiskit-OpenPulse - Thomas Alexander\, Naoki Kanazawa\, Daniel Egger\, Ali Javadi-Abhari\, David C. McKay
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T225514Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T115000Z
DTEND:20200119T121000Z
DTSTAMP:20191226T230629Z
UID:656c66db-ab37-4a54-81cf-9073d5cf9911@conf.researchr.org
CREATED:20191202T190757Z
SUMMARY:[PLanQC] Tracking Errors through Types in Quantum Programs - Kesha Hietala\, Robert Rand\, Michael Hicks
DESCRIPTION:Errors will be prevalent in near-term quantum computing and need to be taken into account when designing quantum algorithms. It is thus reasonable to provide language-level support for reasoning about errors in quantum programs\, in the style of existing tools for classical languages. We present a simple type-based approach to reasoning about fault tolerance in quantum programs. Our implementation extends QWIRE and is available at https://github.com/inQWIRE/QWIRE/tree/error_wires.
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191209T232022Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T121000Z
DTEND:20200119T123000Z
DTSTAMP:20191226T230629Z
UID:6818d734-c98b-47c3-b440-8ddef00792c8@conf.researchr.org
CREATED:20191202T190757Z
SUMMARY:[PLanQC] Quantum CPOs - Andre Kornell\, Bert Lindenhovius\, Michael Mislove
DESCRIPTION:This submission introduces the monoidal closed category qCPO of quantum cpos\, whose objects are `quantized’ analogs of omega-complete partial orders (cpos). The category qCPO is enriched over CPO\, and contains both the category CPO of cpos\, and the opposite of the category FdAlg of finite-dimensional operator algebras as monoidal subcategories. The category qCPO enjoys the same properties that make CPO so useful for the semantics of higher-order programming languages that support recursion. Since every finite-dimensional operator algebra is a quantum cpo\, qCPO is a natural candidate for modeling higher-order quantum programming languages that support recursion. Indeed\, we use qCPO to construct a sound model for the quantum programming language Proto-Quipper-M (PQM) extended with term recursion\; this same model also is a sound and computationally adequate model for LNL-FPC\, a circuit-free fragment of PQM with recursive types\, which can also be regarded as an extension of FPC with linear types. Previously the only known adequate model for LNL-FPC was within CPO\, but CPO is not a model for PQM.
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191226T102525Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T103000Z
DTEND:20200119T110000Z
DTSTAMP:20191226T230629Z
UID:5befe1a9-0f20-4531-881c-246dd11cdade@conf.researchr.org
CREATED:20191206T000349Z
SUMMARY:[VMCAI] Witnessing Secure Compilation - Kedar Namjoshi\, Lucas M. Tabajara
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T110000Z
DTEND:20200119T113000Z
DTSTAMP:20191226T230629Z
UID:670a25c3-fe79-47d9-b3d5-8aafa84e0866@conf.researchr.org
CREATED:20191206T000349Z
SUMMARY:[VMCAI] BackFlow: Backward Context-sensitive Flow Reconstruction of Taint Analysis Results - Pietro Ferrara\, Luca Olivieri\, Fausto Spoto
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T113000Z
DTEND:20200119T120000Z
DTSTAMP:20191226T230629Z
UID:b3f98ea0-da30-44b2-a7a3-0a47c00ec45e@conf.researchr.org
CREATED:20191206T000349Z
SUMMARY:[VMCAI] Mini Break
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T120000Z
DTEND:20200119T123000Z
DTSTAMP:20191226T230629Z
UID:cf50f61d-1b9a-432a-84a3-a498207e0bc9@conf.researchr.org
CREATED:20191206T000349Z
SUMMARY:[VMCAI] Fixing Code That Explodes Under Symbolic Evaluation - Sorawee Porncharoenwase\, James Bornholt\, Emina Torlak
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T123000Z
DTEND:20200119T140000Z
DTSTAMP:20191226T230629Z
UID:e56df4d5-8c7d-41ed-8328-c23c4d2f1809@conf.researchr.org
CREATED:20191128T065330Z
SUMMARY:[POPL Catering] Lunch
DESCRIPTION:Lunch
LOCATION:Lunch Room -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191128T065511Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T140000Z
DTEND:20200119T142000Z
DTSTAMP:20191226T230629Z
UID:b2c03cce-b58e-48df-892a-1831d228dc80@conf.researchr.org
CREATED:20191203T053239Z
SUMMARY:[PLanQC] Runtime Analysis of Quantum Programs: A Formal Approach - Federico Olmedo\, Alejandro Díaz-Caro
DESCRIPTION:In this extended abstract we provide a first step towards a tool to estimate the resource consumption of programs. We specifically focus on the runtime analysis of programs and\, inspired by recent methods for probabilistic programs\, we develop a calculus à la weakest precondition to formally and systematically derive the (exact) runtime of quantum programs. Notably\, the calculus admits a notion of loop runtime invariant that can be readily used to derive upper bounds of their runtime. To conclude\, we show the applicability of our calculus analyzing the runtime of an algorithm based on the BB84 quantum key distribution protocol.
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191209T203050Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T142000Z
DTEND:20200119T144000Z
DTSTAMP:20191226T230629Z
UID:14087b20-8fe5-4726-80c0-08c338bf1b0d@conf.researchr.org
CREATED:20191203T053239Z
SUMMARY:[PLanQC] Qbricks: formal verification in quantum computing - Christopĥe Chareton\, Sebastien Bardin\, François Bobot\, Valentin Perrelle\, Benoit Valiron
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T053311Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T144000Z
DTEND:20200119T150500Z
DTSTAMP:20191226T230629Z
UID:1f98a122-5a9a-4258-832d-28f35aa4b6c4@conf.researchr.org
CREATED:20191203T053239Z
SUMMARY:[PLanQC] Merged Talk: A Verified Optimizer for Quantum Circuits & Verified Translation Between Low-Level Quantum Languages - Kesha Hietala\, Kartik Singhal\, Robert Rand\, Shih-Han Hung\, Xiaodi Wu\, Michael Hicks
DESCRIPTION:Merger of \nA Verified Optimizer for Quantum Circuits \nhttps://popl20.sigplan.org/details/planqc-2020-papers/9/A-Verified-Optimizer-for-Quantum-Circuits \nand \nVerified Translation Between Low-Level Quantum Languages \nhttps://popl20.sigplan.org/details/planqc-2020-papers/12/Verified-translation-between-low-level-quantum-languages
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T053513Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T140000Z
DTEND:20200119T150500Z
DTSTAMP:20191226T230629Z
UID:86aea351-050c-4048-885e-4c72b93ce51d@conf.researchr.org
CREATED:20191205T235942Z
SUMMARY:[VMCAI] The Siren Song of Temporal Synthesis  - Moshe Vardi
DESCRIPTION:One of the most significant developments in the area of design verification over the last three decade is the development of algorithmic methods for verifying temporal specification of finite-state designs. A frequent criticism against this approach\, however\, is that verification is done after significant resources have already been invested in the development of the design. Since designs invariably contains errors\, verification simply becomes part of the debugging process. The critics argue that the desired goal is to use temporal specification in the design development process in order to guarantee the development of correct designs. This is called temporal synthesis. In this talk I will review 60 years of research on the temporal synthesis problem\, describe the automata-theoretic approach developed to solve this problem\, and describe both successes and failures of this research program.
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T073345Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T153500Z
DTEND:20200119T155500Z
DTSTAMP:20191226T230629Z
UID:965aef42-c10a-4a68-831d-da6b008f9f4b@conf.researchr.org
CREATED:20191203T055515Z
SUMMARY:[PLanQC] Optimal Two-Qubit Circuits for Universal Fault-Tolerant Quantum Computation - Andrew N. Glaudell\, Neil Julien Ross\, Jacob M. Taylor
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T055536Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T155500Z
DTEND:20200119T161500Z
DTSTAMP:20191226T230629Z
UID:d5e1ec52-117b-4709-8af7-3a917f4df7da@conf.researchr.org
CREATED:20191203T055515Z
SUMMARY:[PLanQC] Context-Sensitive and Duration-Aware Qubit Mapping for Various NISQ Devices - Yu Zhang\, Haowei Deng\, Quanxi Li
DESCRIPTION:Quantum computing (QC) technologies have reached a second renaissance in the last decade. Some fully programmable QC devices have been built based on superconducting or ion trap technologies. Although different quantum technologies have their own parameter indicators\, QC devices in the NISQ era share common features and challenges such as limited qubits and connectivity\, short coherence time and high gate error rates. Quantum programs written by programmers could hardly run on real hardware directly since two-qubit gates are usually allowed on few pairs of qubits. Therefore\, quantum computing compilers must resolve the mapping problem and transform original programs to fit the hardware limitation. \nTo address the issues mentioned above\, we summarize different quantum technologies and abstractly define Quantum Abstract Machine (QAM)\; then propose a COntext-sensitive and Duration-Aware Remapping algorithm (CODAR) based on the QAM. By introducing lock for each qubit\, CODAR is aware of gate duration difference and program context\, which bring it abilities to extract more program’s parallelism and reduce program execution time. Compared to the best known algorithm\, CODAR halves the total execution time of several quantum algorithms and cut down 17.5% ~ 19.4% total execution time on average in different architectures.
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191214T021101Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T161500Z
DTEND:20200119T163500Z
DTSTAMP:20191226T230629Z
UID:6aeb49c9-4add-4fd9-aadc-d0b50de6b9d1@conf.researchr.org
CREATED:20191203T055515Z
SUMMARY:[PLanQC] Quingo: A Domain Specific Language for Quantum Computing with NISQ Features - Xiang Fu\, Jintao Yu\, Xing Su\, Hanru Jiang\, Hua Wu\, Dong Chen\, Fucheng Cheng\, Xi Deng\, Jinrong Zhang\, Lei Jin\, Yihang Yang\, Le Xu\, Chunchao Hu\, Anqi Huang\, Guangyao Huang\, Xiaogang Qiang\, Mingtang Deng\, Ping Xu\, Wanwei Liu\, Yuxin Deng\, Junjie Wu\, Yuan Feng
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T172031Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T153500Z
DTEND:20200119T160730Z
DTSTAMP:20191226T230629Z
UID:d35bf788-d93a-4f30-82cc-e20d31b4f2ac@conf.researchr.org
CREATED:20191206T000402Z
SUMMARY:[VMCAI] The Correctness of a Code Generator for a Functional Language - Nathanaël Courant\, Antoine Sere\, Natarajan Shankar
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T160730Z
DTEND:20200119T164000Z
DTSTAMP:20191226T230629Z
UID:a9399ed7-9ebd-4d0f-9857-c1174465c15c@conf.researchr.org
CREATED:20191206T000402Z
SUMMARY:[VMCAI] Leveraging Compiler Intermediate Representation for Multi- and Cross-Language Verification - Jack Garzella\, Marek S. Baranowski\, Shaobo He\, Zvonimir Rakamaric
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191221T120240Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T164000Z
DTEND:20200119T171230Z
DTSTAMP:20191226T230629Z
UID:0aa4e920-c701-4248-be23-73612a45fd9b@conf.researchr.org
CREATED:20191206T000402Z
SUMMARY:[VMCAI] Mini Break
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T171230Z
DTEND:20200119T174500Z
DTSTAMP:20191226T230629Z
UID:46b79905-5cfe-4276-9e3c-e12a84405c2f@conf.researchr.org
CREATED:20191206T000402Z
SUMMARY:[VMCAI] Putting the Squeeze on Array Programs: Loop Verification via Inductive Rank Reduction - Oren Ish-Shalom\, Shachar Itzhaky\, Noam Rinetzky\, Sharon Shoham
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T165000Z
DTEND:20200119T171000Z
DTSTAMP:20191226T230629Z
UID:fc4cf41d-2b0c-4735-a995-0e47cd0e76da@conf.researchr.org
CREATED:20191203T055415Z
SUMMARY:[PLanQC] Extending Modern C++ for Heterogeneous Quantum-Classical Computing - Alexander McCaskey\, Tiffany Mintz\, Eugene Dumitrescu\, Sarah Powers\, Shirley Moore\, Pavel Lougovski
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T055515Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T171000Z
DTEND:20200119T173000Z
DTSTAMP:20191226T230629Z
UID:a60c8f6d-1b73-46e8-8001-7ebaae2c7b45@conf.researchr.org
CREATED:20191203T055415Z
SUMMARY:[PLanQC] Formalization of a Programming Language for Quantum Circuits with Measurement and Classical Control - Dongho LEE\, Sebastien Bardin\, Valentin Perrelle\, Benoit Valiron
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T055515Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200119T173000Z
DTEND:20200119T175000Z
DTSTAMP:20191226T230629Z
UID:b870482f-589c-4808-8f94-ee2b65a25f70@conf.researchr.org
CREATED:20191203T055415Z
SUMMARY:[PLanQC] Automated distribution of quantum circuits via hypergraph partitioning - Pablo Andres-Martinez\, Chris Heunen
DESCRIPTION:
LOCATION:PLanQC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T055515Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T083000Z
DTEND:20200120T084500Z
DTSTAMP:20191226T230629Z
UID:32f6377f-a98a-49ec-a1a7-1cf91cc2da09@conf.researchr.org
CREATED:20191203T062942Z
SUMMARY:[PADL] Opening
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191204T004427Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T084500Z
DTEND:20200120T093500Z
DTSTAMP:20191226T230629Z
UID:8e042a69-bcb4-4825-af8f-887bfa8ecf65@conf.researchr.org
CREATED:20191203T062942Z
SUMMARY:[PADL] Invited Talk: Logical Engines for Cloud Configurations - Nikolaj Bjørner
DESCRIPTION:Abstract: \nConfigurations form a basis for deploying infrastructure and custom instances in today’s hyperscale cloud environments. Similar to conventional program analysis\, configurations can be subjected to logical specifications and checked for correctness claims. In contrast to program analysis\, the analysis relies on information from\, and provides feedback on the health of\, live systems. \nThis talk takes as starting point some of the experiences with using the SMT solver Z3 for checking declarative configurations in the Azure cloud. It then describes solving techniques applied for checking configurations\, and SMT formulas in general. A theme characterizing these solving techniques is how they combine search for a model with deducing logical consequences. The talk provides exemplars of how search and consequence finding is integrated in Z3. \nBiography: \nNikolaj’s main line of work is around the state-of-the-art SMT constraint solver Z3. Z3 received the 2015 ACM SIGPLAN Software System award and most influential tool paper in the first 20 years of TACAS\, and the ETAPS test of time award. Leonardo and Nikolaj received the Herbrand Award at CADE 2019\, in recognition of numerous and important contributions to SMT solving\, including its theory\, implementation\, and application to a wide range of academic and industrial needs. A prolific application is around Network Verification as deployed in the SecGuru tool in Microsoft Azure. In previous work in the Windows File Systems group\, he developed the Distributed File System Replication\, DFS-R\, protocol. He studied at DTU\, DIKU\; and for his Master’s and PhD at Stanford.
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T181946Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T093500Z
DTEND:20200120T100000Z
DTSTAMP:20191226T230629Z
UID:94009611-580e-4c44-9808-eb7229ebe98f@conf.researchr.org
CREATED:20191203T062942Z
SUMMARY:[PADL] Interactive Text Graph Mining with a Prolog-based Dialog Engine - Paul Tarau\, Eduardo Blanco
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191204T004427Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T090000Z
DTEND:20200120T100000Z
DTSTAMP:20191226T230629Z
UID:c5504ec8-2d76-4439-8e54-3914b8af3ca6@conf.researchr.org
CREATED:20191205T051400Z
SUMMARY:[POPL TutorialFest] [T1] Building Program Reasoning Tools using LLVM and Z3 - Elizabeth Dinella\, Pardis Pashakhanloo\, Anthony Canino\, Mayur Naik
DESCRIPTION:Program reasoning has important and wide-ranging applications in programming languages\, such as type inference\, static analysis\, testing\, verification\, and synthesis. This tutorial will cover how to build program reasoning tools using two versatile\, modern\, and open-source systems: the LLVM compiler infrastructure and the Z3 constraint solver. These systems underlie state-of-the-art tools such as Clang Static Analyzer\, the KLEE symbolic execution engine\, and the SeaHorn verification framework. \nThis tutorial will introduce LLVM and Z3’s architecture and conduct three hands-on exercises. The exercises will target common applications in program reasoning that embody three distinctive use-cases: static dataflow analysis\, dynamic symbolic execution\, and assertion verification. The target audience for this tutorial is those who want hands-on experience with state-of-the-art tools and techniques employed in program reasoning. The tutorial presumes background in C++ programming and basic logical reasoning.
LOCATION:TutorialFest-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052150Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T090000Z
DTEND:20200120T100000Z
DTSTAMP:20191226T230629Z
UID:1ee5a56c-afc9-468f-a693-5ebd3bee1302@conf.researchr.org
CREATED:20191205T235951Z
SUMMARY:[VMCAI] Model Checking for Safe Autonomy - Rajeev Alur
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T090000Z
DTEND:20200120T100000Z
DTSTAMP:20191226T230629Z
UID:19031f28-1f37-4c0f-a794-107bd9b951d0@conf.researchr.org
CREATED:20191212T181346Z
SUMMARY:[CPP] Invited talk: Matching Logic: The Foundation of the K Framework - Grigore Rosu\, Xiaohong Chen
DESCRIPTION:The K framework (kframework.org) is an effort in realizing the ideal language framework\, where programming languages must have formal semantics and all language tools are automatically generated from the formal semantics. Until recently\, K has been developed as an engineering endeavor driven by challenges such as formalizing the complete semantics of large languages (C\, Java\, JavaScript\, Python\, etc)\, but deriving its semantics from translations to various formalisms\, such as rewriting logic\, graph transformations\, or Coq. This semantics borrowing approach came not only at a notational cost\, where the original language meaning was ``lost in translation''\, but also at a foundational cost: the target formalisms were more complicated than necessary\, yet more restricted due to their prescribed ways to define language semantics. \nIn this talk I will present matching logic as the new and direct foundation of K. I will also discuss some of its applications in defining constructors\, transition systems\, modal mu-logic and temporal logic variants\, reachability logic and thus Hoare logics\, and separation-logic-style recursive predicates and patterns. Matching logic can therefore be regarded as an expressive foundation for programming languages\, and K as a best effort implementation. An appealing aspect of matching logic’s Hilbert-style proof system is that it admits a small proof checker\, in the order of 200 LOC including parsing.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T090000Z
DTEND:20200120T100000Z
DTSTAMP:20191226T230629Z
UID:ac8697eb-dfef-4269-b903-a41733a39772@conf.researchr.org
CREATED:20191217T213220Z
SUMMARY:[ADSL] Relational reasoning using concurrent separation logic - Robbert Krebbers
DESCRIPTION:Relational reasoning plays an important role in programming languages. For example\, it is used to show that optimized versions of data structures behave the same as their non-optimized versions (contextual equivalence)\, to prove linearizability of concurrent data structures (contextual refinement)\, to prove correctness of program transformations (contextual refinement)\, and to prove that varying secret information does not lead to different behavior that can be observed by attackers (non-interference). In this talk\, I will describe recent developments in concurrent separation logic (in the context of the Iris framework in the Coq proof assistant) that enable modular and mechanized relation reasoning in the context of rich languages with higher-order state and fine-grained concurrency.
LOCATION:ADSL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191217T213220Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T090000Z
DTEND:20200120T090500Z
DTSTAMP:20191226T230629Z
UID:76ecc5dc-315c-440d-ada0-8c9495f55f91@conf.researchr.org
CREATED:20191211T000336Z
SUMMARY:[PEPM] Opening - Casper Bach Poulsen\, Zhenjiang Hu
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191211T004321Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T090500Z
DTEND:20200120T100000Z
DTSTAMP:20191226T230629Z
UID:6ea2c457-ab1d-4595-aacc-f135d1c89b93@conf.researchr.org
CREATED:20191211T000336Z
SUMMARY:[PEPM] Network Verification: Past\, Present\, and Future - Nate Foster
DESCRIPTION:Networks today achieve robustness not by adhering to precise formal specifications but by building implementations that tolerate modest deviations from correct behavior. This philosophy can be seen in the slogan used by the Internet Engineering Task Force\, “we believe in rough consensus and running code\,” and by Jon Postel’s famous dictum to “be conservative in what you do\, be liberal in what you accept from others.” But as networks have grown in scale and complexity\, the frequency of faults has led to new interest in techniques for formally verifying network behavior. \nThis talk will discuss recent progress on practical tools for specifying and verifying formal properties of networks. In the first part of the talk\, I will present p4v\, a tool for verifying the low-level code that executes on individual devices such as routers and firewalls. In the second part of the talk\, I will present NetKAT\, a formal system for specifying and verifying network-wide behavior. In the third part of the talk\, I will highlight some challenges and opportunities for future research in network verification.
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191211T004151Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T090000Z
DTEND:20200120T100000Z
DTSTAMP:20191226T230629Z
UID:eee6c39a-5c1c-4db1-bf35-71cd8affc386@conf.researchr.org
CREATED:20191205T051539Z
SUMMARY:[POPL TutorialFest] [T3] Synthesizing Programs from Types - Nadia Polikarpova
DESCRIPTION:The goal of program synthesis is to generate programs automatically from high-level declarative specifications. But what form should these specifications take? In this tutorial we will explore the use of expressive types as the input to program synthesis. In particular\, we will focus on the SYNQUID synthesizer that generates recursive programs from refinement types—types decorated with simple predicates. \nThe tutorial is organized in two parts. In the first part\, we will cover the fundamentals of refinement types and go through a series of exercises using SYNQUID to synthesize a range of data structure manipulation. In the second part\, I will introduce a recent extension to SYNQUID called RESYN\, which allows you to augment refinement types with potential annotations to specify the desired resource consumption of a program.
LOCATION:TutorialFest-C -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052135Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T090000Z
DTEND:20200120T100000Z
DTSTAMP:20191226T230630Z
UID:84990a6e-6a16-4815-b682-017a9c80257f@conf.researchr.org
CREATED:20191205T052111Z
SUMMARY:[POPL TutorialFest] [T2] Verified Quantum Computing - Robert Rand
DESCRIPTION:This tutorial will introduce quantum computing to a programming languages audience through use of the Coq proof assistant. It will use the author’s recent Software Foundations-inspired textbook Verified Quantum Computing. Beyond introducing attendees to the basics of quantum computing\, it will introduce a simple quantum programming language\, called SQIR\, and demonstrate how to verify the correctness of quantum programs. \nBy the end of workshop\, attendees will have a concrete understanding of core quantum computing concepts\, including superposition\, entanglement and measurement\, and be able to write and verify small quantum programs. (Basic familiarity with Coq or similar proof assistants will be assumed.)
LOCATION:TutorialFest-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052111Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T090000Z
DTEND:20200120T100000Z
DTSTAMP:20191226T230630Z
UID:14445a9d-b169-4439-ab6c-8933516eefc8@conf.researchr.org
CREATED:20191205T052057Z
SUMMARY:[POPL TutorialFest] [T6] Verifying Probabilistic Properties with Couplings - Justin Hsu
DESCRIPTION:In the past few years\, probabilistic couplings have been identified as a powerful abstraction for verifying probabilistic properties. Originating from research in probability theory\, a coupling is a distribution over pairs that relates—or couples—two given distributions. If we can find a coupling with certain properties\, then we can conclude properties about the two related distributions. In this way\, probabilistic relational properties—properties comparing two executions of a probabilistic program—can be established by building a suitable coupling. \nCouplings have also been explored in the logic and verification literature. For example\, probabilistic bisimulation assert that there exists a coupling\; in this way\, couplings can be used to verify equivalence of finite state probabilistic transition systems. However\, their use in mathematics suggests that couplings can prove more sophisticated properties for richer probabilistic computations\, such as imperative programs and infinite state systems. Furthermore\, we can borrow a tool from probability theory called proof by coupling to construct couplings in a compositional fashion. \nThis tutorial will survey recent techniques in program verification for building and reasoning about probabilistic couplings. These methods have enabled the first formal verification of probabilistic algorithms and properties that previously seemed out of reach. Target properties range from program equivalence and probabilistic independence to more complex guarantees\, such as convergence of random walks and differential privacy. This tutorial will first give participants and intuitive feel for how to apply proofs by coupling\, for formal or informal reasoning\, and then demonstrate how this technique can be formalized in logic.
LOCATION:TutorialFest-D -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052145Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T103000Z
DTEND:20200120T105500Z
DTSTAMP:20191226T230630Z
UID:b7e42bc7-0875-45c7-95a2-b6aefbfe6a4d@conf.researchr.org
CREATED:20191202T204403Z
SUMMARY:[PADL] AQuA: ASP-based Visual Question Answering - Kinjal Basu\, Farhad Shakerin\, Gopal Gupta
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T220347Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T105500Z
DTEND:20200120T111000Z
DTSTAMP:20191226T230630Z
UID:33bb3371-55a5-4738-a545-a574cbbdf090@conf.researchr.org
CREATED:20191202T204403Z
SUMMARY:[PADL] Diagnosing Data Pipeline Failures Using Action Languages: A Progress Report - Alex Brik\, Jeffrey Xu
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T220450Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T111000Z
DTEND:20200120T112500Z
DTSTAMP:20191226T230630Z
UID:754683f1-afac-4b0c-9f5f-c50746f17ebc@conf.researchr.org
CREATED:20191202T204403Z
SUMMARY:[PADL] VRASP: A Virtual Reality Environment for Learning Answer Set Programming - Vinh The Nguyen\, Yuanlin Zhang\, Kwanghee Jung\, Wanli Xing\, Tommy Dang
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T220457Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T112500Z
DTEND:20200120T120000Z
DTSTAMP:20191226T230630Z
UID:0155e68e-eac7-466e-a0c5-abfa29387a25@conf.researchr.org
CREATED:20191202T204403Z
SUMMARY:[PADL] Panel: Programming with logic for the masses - Nikolaj Bjørner\, Paul Tarau\, Eduardo Blanco\, Kinjal Basu\, Farhad Shakerin\, Gopal Gupta\, Alex Brik\, Jeffrey Xu\, Vinh The Nguyen\, Yuanlin Zhang\, Kwanghee Jung\, Wanli Xing\, Tommy Dang
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T220510Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T103000Z
DTEND:20200120T123000Z
DTSTAMP:20191226T230630Z
UID:1ece3e02-01ef-4d64-9b26-a6c7cfeb7821@conf.researchr.org
CREATED:20191205T052150Z
SUMMARY:[POPL TutorialFest] [T1] Building Program Reasoning Tools using LLVM and Z3 - Elizabeth Dinella\, Pardis Pashakhanloo\, Anthony Canino\, Mayur Naik
DESCRIPTION:Program reasoning has important and wide-ranging applications in programming languages\, such as type inference\, static analysis\, testing\, verification\, and synthesis. This tutorial will cover how to build program reasoning tools using two versatile\, modern\, and open-source systems: the LLVM compiler infrastructure and the Z3 constraint solver. These systems underlie state-of-the-art tools such as Clang Static Analyzer\, the KLEE symbolic execution engine\, and the SeaHorn verification framework. \nThis tutorial will introduce LLVM and Z3’s architecture and conduct three hands-on exercises. The exercises will target common applications in program reasoning that embody three distinctive use-cases: static dataflow analysis\, dynamic symbolic execution\, and assertion verification. The target audience for this tutorial is those who want hands-on experience with state-of-the-art tools and techniques employed in program reasoning. The tutorial presumes background in C++ programming and basic logical reasoning.
LOCATION:TutorialFest-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052150Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T103000Z
DTEND:20200120T110000Z
DTSTAMP:20191226T230630Z
UID:734ab3af-d89e-4cad-aa5e-cd4bd9b3bfd7@conf.researchr.org
CREATED:20191206T000421Z
SUMMARY:[VMCAI] A Systematic Approach to Abstract Interpretation of Program Transformations - Sven Keidel\, Sebastian Erdweg
DESCRIPTION:Abstract interpretation is a technique to define sound static analyses. While abstract interpretation is generally well-understood\, the analysis of program transformations has not seen much attention. The main challenge in developing an abstract interpreter for program transformations is designing good abstractions that capture relevant information about the generated code. However\, a complete abstract interpreter must handle many other aspects of the transformation language\, such as backtracking and generic traversals\, as well as analysis-specific concerns\, such as interprocedurality and fixpoints. This deflects attention. \nWe propose a systematic approach to design and implement abstract interpreters for program transformations that isolates the abstraction for generated code from other analysis aspects. Using our approach\, analysis developers can focus on the design of abstractions for generated code\, while the rest of the analysis definition can be reused. We show that our approach is feasible and useful by developing three novel inter-procedural analyses for the Stratego transformation language: a singleton analysis for constant propagation\, a sort analysis for type checking\, and a locally-illsorted sort analysis that can additionally validate type changing generic traversals.
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T110000Z
DTEND:20200120T113000Z
DTSTAMP:20191226T230630Z
UID:03d16f68-6d6b-4086-a191-7a95553f8dae@conf.researchr.org
CREATED:20191206T000421Z
SUMMARY:[VMCAI] Sharing Ghost Variables in a Collection of Abstract Domains - Marc Chevalier\, Jerome Feret
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191221T120324Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T113000Z
DTEND:20200120T120000Z
DTSTAMP:20191226T230630Z
UID:59d5ee9c-aad5-4ed9-880e-1918aaeea772@conf.researchr.org
CREATED:20191206T000421Z
SUMMARY:[VMCAI] Mini Break
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T120000Z
DTEND:20200120T123000Z
DTSTAMP:20191226T230630Z
UID:c027c73b-9604-4688-a162-fad082e26edd@conf.researchr.org
CREATED:20191206T000421Z
SUMMARY:[VMCAI] Harnessing Static Analysis to Help Learn Pseudo-Inverses of String Manipulating Procedures for Automatic Test Generation - Oren Ish-Shalom\, Shachar Itzhaky\, Roman Manevich\, Noam Rinetzky
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T103000Z
DTEND:20200120T105100Z
DTSTAMP:20191226T230630Z
UID:b3b0c9bc-511a-401c-87f7-d7b3e210e1e3@conf.researchr.org
CREATED:20191212T182110Z
SUMMARY:[CPP] A Verified Packrat Parser Interpreter for Parsing Expression Grammars - Clement Blaudeau\, Natarajan Shankar
DESCRIPTION:Parsing expression grammars (PEGs) offer a natural opportunity for building verified parser interpreters based on higher-order parsing combinators. PEGs are expressive\, unambiguous\, and efficient to parse in a top-down recursive descent style. We use the rich type system of the PVS specification language and verification system to formalize the metatheory of PEGs and define a reference implementation of a recursive parser interpreter for PEGs. In order to ensure termination of parsing\, we define a notion of a well-formed grammar. Rather than relying on an inductive definition of parsing\, we use abstract syntax trees that represent the computational trace of the parser to provide an effective proof certificate for correct parsing and ensure that parsing properties including soundness and completeness are maintained. The correctness properties are embedded in the types of the operations so that the proofs can be easily constructed from local proof obligations. Building on the reference parser interpreter\, we define a packrat parser interpreter as well as an extension that is capable of semantic interpretation. Both these parser interpreters are proved equivalent to the reference one. All of the parsers are executable. The proofs are formalized in mathematical terms so that similar parser interpreters can be defined in any specification language with a type system similar to PVS.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T222732Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T105100Z
DTEND:20200120T111300Z
DTSTAMP:20191226T230630Z
UID:44a9f108-f33a-4569-b23d-570c7dda5cb2@conf.researchr.org
CREATED:20191212T182110Z
SUMMARY:[CPP] Proof Pearl: Braun Trees - Tobias Nipkow\, Thomas Sewell
DESCRIPTION:Braun trees are functional data structures for implementing extensible arrays and priority queues (and sorting functions based on the latter) efficiently. Some well-known functions on Braun trees have not yet been verified\, including especially Okasaki’s linear time conversion from lists to Braun trees. We supply the missing proofs and verify all of these algorithms in Isabelle\, including non-obvious time complexity claims. In particular we provide the first linear-time conversion from Braun trees to lists. We also state and verify a new characterization of Braun trees as the trees t whose index set is the interval {1\, … size of t}.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T111300Z
DTEND:20200120T113500Z
DTSTAMP:20191226T230630Z
UID:71936394-3947-485a-ad5d-558fdfc65e05@conf.researchr.org
CREATED:20191212T182110Z
SUMMARY:[CPP] Astructio: Specifying\, Verifying and Executing Impure Computations in Coq - Thomas Letan\, Yann Régis-Gianas
DESCRIPTION:Astructio is a framework for the Coq theorem prover which allows for implementing\, specifying and verifying complex systems as hierarchies of components verified both in isolation and in composition. Astructio was originally designed for reasoning about hardware architectures. In this article\, we present a new iteration on the Astructio formalism we call Mutual Obligations logic specifically designed to develop certified programs and libraries. Then\, we present how we use this formalism to verify a webserver for static files. We use this opportunity to present Astructio proof automation tactics\, and demonstrate how they successfully erase Astructio internal definitions to let users focus on the core goals of their proofs. Finally\, we introduce Astructio.Exec\, a plugin for Coq to seamlessly execute certified programs written with Astructio.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T103000Z
DTEND:20200120T110000Z
DTSTAMP:20191226T230630Z
UID:26465bbe-2083-4aea-99db-f1eaf1d306e8@conf.researchr.org
CREATED:20191217T212938Z
SUMMARY:[ADSL] Extending the Profile Abstraction for Complete Entailment Checking of Symbolic Heaps of Bounded Treewidth - Florian Zuleger\, Jens Katelaan
DESCRIPTION:At TACAS 2019\, we published a decision procedure for the entailment problem for symbolic-heap separation logic with inductive definitions of bounded treewidth based on a novel abstraction we called the profile abstraction. Since then\, we have discovered an incompleteness issue with that decision procedure\, as well as a generalization of the profile abstraction that fixes the issue. In this article\, we give a high-level discussion of the approach of our TACAS paper\, identify the reason for its incompleteness\, and explain the necessary changes to obtain a complete decision procedure while retaining the same asymptotic complexity. A complementary article with a full formalization of the extended decision procedure is currently under preparation.
LOCATION:ADSL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191217T212938Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T110000Z
DTEND:20200120T113000Z
DTSTAMP:20191226T230630Z
UID:d7bcdaf3-12cc-42fc-8328-2d68ae3a8ea9@conf.researchr.org
CREATED:20191217T212938Z
SUMMARY:[ADSL] Steel: scaling up memory reasoning for F* - Denis Merigoux\, Aymeric Fromherz
DESCRIPTION:We present Steel\, a semi-automated separation logic framework for the F* proof assistant. Steel is built as a set of verified libraries on top of an existing C-like subset language and memory model\, Low*. It relies on the careful mixing of separation logic terms describing the heap together with functional specifications to offer an improved proof development experience compared to current Low*\, already used for large-scale projects going over several thousands lines of code. While manipulation of separation logic terms is ensured by F* tactics\, the rest of the functional verification conditions is still discharged to the Z3 theorem prover. Bundling fractional permissions and a basic fork-join concurrency model\, Steel is designed to automate by tactics the most common patterns of separation logic proofs such as the application of the frame rule in a populated context. While lacking proper evaluation and currently suffering from F* tactics performance issue\, we hope to demonstrate its usefulness in the coming year.
LOCATION:ADSL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191217T212938Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T113000Z
DTEND:20200120T120000Z
DTSTAMP:20191226T230630Z
UID:d04116c8-7806-42f6-aa0f-6f3e67eda6a4@conf.researchr.org
CREATED:20191217T212938Z
SUMMARY:[ADSL] Strong-Separation Logic - Florian Zuleger\, Jens Katelaan
DESCRIPTION:Most automated verifiers for separation logic target the symbolic-heap fragment\, disallowing both the magic-wand operator and the application of classical Boolean operators to spatial formulas. This is not surprising\, as support for the magic wand quickly leads to undecidability\, especially when combined with inductive predicates for reasoning about data structures. \nTo circumvent these undecidability results\, we propose to assign a more restrictive semantics to the separating conjunction. We argue that the resulting logic\, strong-separation logic\, can be used for compositional program verification and bi-abductive static analysis just like ``standard'' separation logic\, while remaining decidable even in the presence of both the magic wand and the list-segment predicate—a combination of features that leads to undecidability assuming the standard semantics.
LOCATION:ADSL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191217T212938Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T120000Z
DTEND:20200120T123000Z
DTSTAMP:20191226T230630Z
UID:b5b2f4d7-0c6a-4f75-b2e4-8ee9add18ad6@conf.researchr.org
CREATED:20191217T212938Z
SUMMARY:[ADSL] The Lower Bound of Decidable Entailments in Separation Logic with Inductive Definitions - Mnacho Echenim\, Radu Iosif\, Nicolas Peltier
DESCRIPTION:The entailment between separation logic formulae with inductive predicates (also known as symbolic heaps) has been shown to be decidable for a large class of inductive definitions. Recently\, a 2EXPTIME algorithm has been proposed\, however no precise lower bound is known (although a EXPTIME-hard bound for this problem has been established). In this paper\, we show that deciding entailment between predicate atoms is 2EXPTIME-hard. The proof is based on a reduction from the membership problem for exponential-space bounded alternating Turing machines.
LOCATION:ADSL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191217T212938Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T103000Z
DTEND:20200120T110500Z
DTSTAMP:20191226T230630Z
UID:8ec1b0b5-2579-4337-bf41-87bb6de4a371@conf.researchr.org
CREATED:20191211T004537Z
SUMMARY:[PEPM] Dependently-Typed Multi-Stage Programming Revisited (invited talk) - Atsushi Igarashi
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191211T004736Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T110500Z
DTEND:20200120T113000Z
DTSTAMP:20191226T230630Z
UID:05409bc8-9740-4b27-a5b5-5455fbfc57fb@conf.researchr.org
CREATED:20191211T004537Z
SUMMARY:[PEPM] High-Fidelity Metaprogramming with Separator Syntax Trees - Rodin Aarssen\, Tijs van der Storm
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T025252Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T113000Z
DTEND:20200120T114500Z
DTSTAMP:20191226T230630Z
UID:e5ecf30d-e961-49d5-9dac-3ea97410661a@conf.researchr.org
CREATED:20191211T004537Z
SUMMARY:[PEPM] Mini Break 1
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191211T010055Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T114500Z
DTEND:20200120T121000Z
DTSTAMP:20191226T230630Z
UID:da7dc036-c6e8-4eac-8e8a-b8bd5a2c170a@conf.researchr.org
CREATED:20191211T004537Z
SUMMARY:[PEPM] Module Generation without Regret - Yuhi Sato\, Yukiyoshi Kameyama\, Takahisa Watanabe
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T025305Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T121000Z
DTEND:20200120T123000Z
DTSTAMP:20191226T230630Z
UID:95888831-c6b8-4446-9ca7-8082b110dfc7@conf.researchr.org
CREATED:20191211T004537Z
SUMMARY:[PEPM] GOOL: A Generic Object-Oriented Language - Jacques Carette\, Brooks MacLachlan\, Spencer Smith
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T025237Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T103000Z
DTEND:20200120T123000Z
DTSTAMP:20191226T230630Z
UID:edfb6d56-c2ea-4feb-aa8d-96586839170a@conf.researchr.org
CREATED:20191205T051601Z
SUMMARY:[POPL TutorialFest] [T3] Synthesizing Programs from Types - Nadia Polikarpova
DESCRIPTION:The goal of program synthesis is to generate programs automatically from high-level declarative specifications. But what form should these specifications take? In this tutorial we will explore the use of expressive types as the input to program synthesis. In particular\, we will focus on the SYNQUID synthesizer that generates recursive programs from refinement types—types decorated with simple predicates. \nThe tutorial is organized in two parts. In the first part\, we will cover the fundamentals of refinement types and go through a series of exercises using SYNQUID to synthesize a range of data structure manipulation. In the second part\, I will introduce a recent extension to SYNQUID called RESYN\, which allows you to augment refinement types with potential annotations to specify the desired resource consumption of a program.
LOCATION:TutorialFest-C -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052135Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T103000Z
DTEND:20200120T123000Z
DTSTAMP:20191226T230630Z
UID:98fee35b-708b-41e3-a2ee-552997381518@conf.researchr.org
CREATED:20191205T051514Z
SUMMARY:[POPL TutorialFest] [T2] Verified Quantum Computing - Robert Rand
DESCRIPTION:This tutorial will introduce quantum computing to a programming languages audience through use of the Coq proof assistant. It will use the author’s recent Software Foundations-inspired textbook Verified Quantum Computing. Beyond introducing attendees to the basics of quantum computing\, it will introduce a simple quantum programming language\, called SQIR\, and demonstrate how to verify the correctness of quantum programs. \nBy the end of workshop\, attendees will have a concrete understanding of core quantum computing concepts\, including superposition\, entanglement and measurement\, and be able to write and verify small quantum programs. (Basic familiarity with Coq or similar proof assistants will be assumed.)
LOCATION:TutorialFest-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052111Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T103000Z
DTEND:20200120T123000Z
DTSTAMP:20191226T230630Z
UID:516d87f0-684a-481f-86c3-251acde97182@conf.researchr.org
CREATED:20191205T052145Z
SUMMARY:[POPL TutorialFest] [T6] Verifying Probabilistic Properties with Couplings - Justin Hsu
DESCRIPTION:In the past few years\, probabilistic couplings have been identified as a powerful abstraction for verifying probabilistic properties. Originating from research in probability theory\, a coupling is a distribution over pairs that relates—or couples—two given distributions. If we can find a coupling with certain properties\, then we can conclude properties about the two related distributions. In this way\, probabilistic relational properties—properties comparing two executions of a probabilistic program—can be established by building a suitable coupling. \nCouplings have also been explored in the logic and verification literature. For example\, probabilistic bisimulation assert that there exists a coupling\; in this way\, couplings can be used to verify equivalence of finite state probabilistic transition systems. However\, their use in mathematics suggests that couplings can prove more sophisticated properties for richer probabilistic computations\, such as imperative programs and infinite state systems. Furthermore\, we can borrow a tool from probability theory called proof by coupling to construct couplings in a compositional fashion. \nThis tutorial will survey recent techniques in program verification for building and reasoning about probabilistic couplings. These methods have enabled the first formal verification of probabilistic algorithms and properties that previously seemed out of reach. Target properties range from program equivalence and probabilistic independence to more complex guarantees\, such as convergence of random walks and differential privacy. This tutorial will first give participants and intuitive feel for how to apply proofs by coupling\, for formal or informal reasoning\, and then demonstrate how this technique can be formalized in logic.
LOCATION:TutorialFest-D -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052145Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T114500Z
DTEND:20200120T120730Z
DTSTAMP:20191226T230630Z
UID:43ae87ea-7d61-4a5e-bc87-427be338f83d@conf.researchr.org
CREATED:20191212T192127Z
SUMMARY:[CPP] Verifying x86 Instruction Implementations - Shilpi Goel\, Anna Slobodova\, Rob Sumners\, Sol Swords
DESCRIPTION:Verification of modern microprocessors is a complex task that requires a substantial allocation of resources. Despite significant progress in formal verification\, the goal of complete verification of an industrial design has not been achieved. In this paper\, we describe a current contribution of formal methods to the validation of modern x86 microprocessors at Centaur Technology. We focus on proving correctness of instruction implementations\, which includes the decoding of an instruction\, its translation into a sequence of micro-operations\, any subsequent execution of traps to microcode ROM\, and the implementation of these micro-operations in execution units. All these tasks are performed within one verification framework\, which includes a theorem prover\, a verified symbolic simulator\, and SAT solvers. We describe the work of defining the needed formal models for both the architecture and micro-architecture in this framework\, as well as tools for decomposing the requisite properties into smaller lemmas which can be automatically checked. We additionally cover the advantages and limitations of our approach. To our knowledge\, there are no similar results in the verification of implementations of an x86 microprocessor.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191226T171851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T120730Z
DTEND:20200120T123000Z
DTSTAMP:20191226T230630Z
UID:b5cc0e3a-5d60-43d0-bacd-0196bfc92198@conf.researchr.org
CREATED:20191212T192127Z
SUMMARY:[CPP] Frying the Egg\, Roasting The Chicken: Unit Deletions in DRAT Proofs - Adrian Rebola Pardo\, Johannes Altmanninger
DESCRIPTION:The clausal proof format DRAT is the standard de facto to certify SAT solvers’ unsatisfiability results.DRAT proofs act as logs of clause inferences and clause deletions in the solver.The non-monotonic nature of the proof system makes deletions relevant. State-of-the-art proof checkers ignore deletions of unit clauses\, differing from the standard in meaningful ways that require adaptions when proofs are generated or used for purposes other than checking. On the other hand\, dealing with unit deletions in the proof checker breaks many of the usual invariants used for efficiency reasons. Furthermore\, many SAT solvers introduce spurious unit deletions in proofs. These deletions are never intended to be applied in the checker but are nevertheless introduced\, making many proofs generated by state-of-the-art solvers incorrect. We present the first competitive DRAT checker that honors unit deletions\, as well as fixes for the spurious deletion issue in proof generation. Our experimental results confirm that unit deletions can be applied with similar average performance to state-of-the-art checkers. We also confirm that a large fraction of the proofs generated during the last SAT solving competition do not respect the DRAT standard. This result was confirmed with proof incorrectness certificates that were independently validated. We find that our proof incorrectness certificates can be of help when debugging SAT solvers and DRAT checkers.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T123000Z
DTEND:20200120T140000Z
DTSTAMP:20191226T230630Z
UID:e065757c-6200-4923-94a1-6c0966fca00e@conf.researchr.org
CREATED:20191128T065455Z
SUMMARY:[POPL Catering] Lunch
DESCRIPTION:Lunch
LOCATION:Lunch Room -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191128T065511Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T133000Z
DTEND:20200120T135500Z
DTSTAMP:20191226T230630Z
UID:28b85232-001e-4c14-a9a0-c718057ceba5@conf.researchr.org
CREATED:20191202T211755Z
SUMMARY:[PADL] On the Effects of Integrating Region-based Memory Managemen and Generational Garbage Collection in ML - Martin Elsman\, Niels Hallenberg
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T220540Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T135500Z
DTEND:20200120T142000Z
DTSTAMP:20191226T230630Z
UID:be3a0761-f1ee-4f1b-93f3-a22e156723d5@conf.researchr.org
CREATED:20191202T211755Z
SUMMARY:[PADL] RTMLton: An SML Runtime for Real-Time Systems - Bhargav Shivkumar\, Jeffrey Murphy\, Lukasz Ziarek
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T220553Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T142000Z
DTEND:20200120T144500Z
DTSTAMP:20191226T230630Z
UID:9da5e3de-4795-4761-9026-32f70ea9a729@conf.researchr.org
CREATED:20191202T211755Z
SUMMARY:[PADL] A Timed IO Monad - David Janin
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T220606Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T144500Z
DTEND:20200120T150000Z
DTSTAMP:20191226T230630Z
UID:6bdc1112-e6cc-457f-9931-91db6e898de1@conf.researchr.org
CREATED:20191202T211755Z
SUMMARY:[PADL] Panel: Memory and real-time programming in practice - Martin Elsman\, Niels Hallenberg\, Bhargav Shivkumar\, Jeffrey Murphy\, Lukasz Ziarek\, David Janin
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T220613Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T140000Z
DTEND:20200120T150500Z
DTSTAMP:20191226T230630Z
UID:9d5f4096-9230-420b-a1b2-e6f07a90a406@conf.researchr.org
CREATED:20191217T192753Z
SUMMARY:[ADSL] SLEdge: Bounded Model Checking in Separation Logic - Josh Berdine
DESCRIPTION:TBA
LOCATION:ADSL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191217T192753Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T140000Z
DTEND:20200120T150000Z
DTSTAMP:20191226T230630Z
UID:6983fd1f-3fa7-46ec-ab34-f72f207f8c3e@conf.researchr.org
CREATED:20191211T002130Z
SUMMARY:[PEPM] Reasoning about Progress of Concurrent Objects - Xinyu Feng
DESCRIPTION:Implementations of concurrent objects should guarantee linearizability and a progress property such as wait-freedom\, lock-freedom\, starvation-freedom\, or deadlock-freedom. These progress properties describe conditions under which a method call is guaranteed to complete. However\, they fail to describe how clients are affected\, making it difficult to utilize them in layered and modular program verification. Also\, we lack verification techniques for starvation-free or deadlock-free objects. They are challenging to verify because the fairness assumption introduces complicated interdependencies among progress of threads. Even worse\, none of the existing results applies to concurrent objects with partial methods\, i.e.\, methods that are supposed NOT to return under certain circumstances. \nIn this talk we examine the progress properties of concurrent objects. We formulate each progress property (together with linearizability as a basic correctness requirement) in terms of contextual refinement. This essentially gives us progress-aware abstraction for concurrent objects. Thus\, when verifying clients of the objects\, we can soundly replace the concrete object implementations with their abstractions\, achieving modular verification. For concurrent objects with partial methods\, we formulate two new progress properties\, partial starvation-freedom (PSF) and partial deadlock-freedom (PDF). Finally\, we introduce a rely-guarantee style program logic LiLi for verifying linearizability and progress together for concurrent objects. It unifies thread-modular reasoning about all the six progress properties (wait-freedom\, lock-freedom\, starvation-freedom\, deadlock-freedom\, PSF and PDF) in one framework. We have successfully applied LiLi to verify starvation-freedom or deadlock-freedom of representative algorithms such as lock-coupling lists\, optimistic lists and lazy lists\, and PSF or PDF of lock algorithms.
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191211T004213Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T140000Z
DTEND:20200120T143230Z
DTSTAMP:20191226T230630Z
UID:9f73cac1-498e-43cb-8c74-34749429d234@conf.researchr.org
CREATED:20191206T000124Z
SUMMARY:[VMCAI] Synthesizing Environment Invariants for Modular Hardware Verification - Hongce Zhang\, Weikun Yang\, Grigory Fedyukovich\, Aarti Gupta\, Sharad Malik
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T143230Z
DTEND:20200120T150500Z
DTSTAMP:20191226T230630Z
UID:49d0729d-7fff-4a70-b15a-264219d72432@conf.researchr.org
CREATED:20191206T000124Z
SUMMARY:[VMCAI] Systematic Classification of Attackers via Bounded Model Checking - Eric Rothstein-Morris\, Jun Sun\, Sudipta Chattopadhyay
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T140000Z
DTEND:20200120T150500Z
DTSTAMP:20191226T230630Z
UID:1a849e59-deb5-4b9a-8c06-bce289a957b8@conf.researchr.org
CREATED:20191205T051911Z
SUMMARY:[POPL TutorialFest] [T7] Programming and Reasoning with Kleene Algebra with Tests - Nate Foster\, Dexter Kozen\, Alexandra Silva
DESCRIPTION:Abstract \nKleene algebra with tests is an algebraic framework that can be used to reason about imperative programs. It has been applied across a wide variety of areas including program transformations\, concurrency control\, compiler optimizations\, cache control\, networking\, and more. \nThis tutorial will provide an overview of Kleene Algebra with Tests\, including the syntax\, semantics\, and the coalgebraic theory underlying decision procedures for program equivalence. We will illustrate how it can be used as a core frameworks for program verification\, including successful extensions and fundamental limitations. \nContext \nComputer scientists have long explored the connections between families of programming languages and abstract machines. This dual perspective has furnished deep theoretical insights as well as practical tools. As an example\, Kleene’s classic result establishing the equivalence of regular expressions and finite automata inspired decades of work across a variety of areas including programming language design\, mathematical semantics\, and formal verification. \nKleene Algebra with Tests (KAT)\, which combines Kleene Algebra (KA) with Boolean Algebra (BA)\, is a modern example of this approach. Viewed from the program-centric perspective\, a KAT models the fundamental constructs that arise in programs: sequencing\, branching\, iteration\, non-determinism\, etc. The equational theory of KAT enables algebraic reasoning and can be finitely axiomatized. Viewed from the machine-centric perspective\, a KAT describes a kind of automaton that generates a regular language of traces. This shift in perspective admits techniques from the theory of coalgebras for reasoning about program behavior. In particular\, there are efficient algorithms for checking bisimulation\, which can be optimized using properties of bisimulations or symbolic automata representations. \nKAT has been used to model computation across a wide variety of areas including program transformations\, concurrency control\, compiler optimizations\, cache control\, and more. A prominent recent application is NetKAT\, a language for reasoning about the packet-forwarding behavior of software-defined networks. NetKAT has a sound and complete equational theory\, and a coalgebraic decision procedure that can be used to automatically verify properties such as reachability\, loop-freedom\, and isolation. \nObjective \nThe objective of this tutorial is to provide attendees with a comprehensive introduction to Kleene Algebra with Tests (KAT) including techniques for using KAT to model and reason about computation in a variety of domains. \nTopics \nThe tutorial will cover the following topics: \n \n Basics: syntax\, denotational semantics\, axiomatization and decision procedure for Kleene Algebra and KAT. \n Applications: using KAT to establish the correctness of a program transformations including the Bohm-Jacopini theorem and the NetKAT to OpenFlow compiler. \n Extensions: systems obtained by enriching KAT with additional equations including NetKAT and KAT+B! \n Limits: fundamental limits on decidability and systems that go beyond the decidable fragment \n \nPresenters \nDexter Kozen is the Joseph Newton Pew\, Jr. Professor in Engineering\, at Cornell University. One of the fathers of dynamic logic and the Mu-calculus\, he is also credited for a number of major contributions in logic\, theory of computation\, automata theory and computational complexity. Dexter is a Fellow of the Association for Computing Machinery\, a Guggenheim Fellow\, and has received numerous awards\, including an Outstanding Innovation Award from IBM\, the EATCS award\, and the honor of a professorship at The Radboud Excellence Initiative\, in the Netherlands. \nNate Foster is an Associate Professor of Computer Science at Cornell University and a Principal Research Engineer at Barefoot Networks. The goal of his research is to develop languages and tools that make it easy for programmers to build secure and reliable systems. His current work focuses on the design and implementation of languages for programming software-defined networks. In the past he has also worked on bidirectional languages (also known as “lenses”)\, database query languages\, data provenance\, type systems\, mechanized proof\, and formal semantics. He received a PhD in Computer Science from the University of Pennsylvania. His honors include a Sloan Research Fellowship\, an NSF CAREER Award\, a Most Influential POPL Paper Award\, and the SIGCOMM Rising Star Award. \nAlexandra Silva is a Professor of Algebra\, Semantics\, and Computation at University College London. Her main research focuses on semantics of programming languages and modular development of algorithms for computational models. Much of her work uses the unifying perspective offered by coalgebra\, a mathematical framework established in the last decades. She was the recipient of the 2018 Needham Award\, 2017 Presburger Award\, 2016 Leverhulme Prize\, and 2015 ERC starting Grant.
LOCATION:TutorialFest-C -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T051911Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T140000Z
DTEND:20200120T142140Z
DTSTAMP:20191226T230630Z
UID:74bdce28-9399-482d-9a2a-726516d09565@conf.researchr.org
CREATED:20191212T192412Z
SUMMARY:[CPP] An Equational Theory for Weak Bisimulation via Generalized Parameterized Coinduction - Yannick Zakowski\, Paul He\, Chung-Kil Hur\, Steve Zdancewic
DESCRIPTION:Coinductive reasoning about infinitary structures such as streams is widely applicable. However\, practical frameworks for developing coinductive proofs and finding reasoning principles that help structure such proofs remain a challenge\, especially in the context of machine-checked formalization. \nThis paper gives a novel presentation of an equational theory for reasoning about structures up to weak bisimulation. The theory is both compositional\, making it suitable for defining general-purpose lemmas\, and also incremental\, meaning that the bisimulation can be created interactively. To prove the theory’s soundness\, this paper also introduces generalized parametric coinduction\, which addresses expressivity problems of earlier works and provides a practical framework for coinductive reasoning. The paper presents the resulting equational theory for streams\, but the technique applies to other structures too. \nAll of the results in this paper have been proved in Coq\, and the generalized parametric coinduction framework is available as a Coq library.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T142140Z
DTEND:20200120T144320Z
DTSTAMP:20191226T230630Z
UID:dd48b440-0dc2-4432-8798-d6cc76e937ad@conf.researchr.org
CREATED:20191212T192412Z
SUMMARY:[CPP] Exploration of Neural Machine Translation in Autoformalization of Mathematics in Mizar - Qingxiang Wang\, Chad Brown\, Cezary Kaliszyk\, Josef Urban
DESCRIPTION:In this paper we share several experiments trying to automatically translate informal mathematics into formal mathematics. In our context informal mathematics refers to human-written mathematical sentences in the LaTeX format\; and formal mathematics refers to statements in the Mizar language. We conducted our experiments against three established neural network-based machine translation models that are known to deliver competitive results on translating between natural languages. To train these models we also prepared four informal-to-formal datasets. We compare and analyze our results according to whether the model is supervised or unsupervised. In order to augment the data available for auto-formalization and improve the results\, we develop a custom type-elaboration mechanism and integrate it in the supervised translation.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T103210Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T144320Z
DTEND:20200120T150500Z
DTSTAMP:20191226T230630Z
UID:bcb01a9e-c4e6-4c73-8f83-4c8c6192e63b@conf.researchr.org
CREATED:20191212T192412Z
SUMMARY:[CPP] REPLICA: REPL Instrumentation for Coq Analysis - Talia Ringer\, Alex Sanchez-Stern\, Dan Grossman\, Sorin Lerner
DESCRIPTION:Proof engineering tools make it easier to develop and maintain large systems verified using interactive theorem provers. Developing useful proof engineering tools hinges on understanding the development processes of proof engineers. This paper breaks down one barrier to achieving that understanding: remotely collecting granular data on proof developments as they happen. \nWe have built a tool called REPLICA that instruments Coq’s interaction model in order to collect fine-grained data on proof developments. It is decoupled from the user interface\, and designed in a way that generalizes to other interactive theorem provers with similar interaction models. \nWe have used REPLICA to collect data over the span of a month from a group of intermediate through expert proof engineers—enough data to reconstruct hundreds of interactive sessions. The data reveals patterns in fixing proofs and in changing programs and specifications useful for the improvement of proof engineering tools. Our experiences conducting this study suggest design considerations both at the level of the study and at the level of the interactive theorem prover that can facilitate future studies of this kind.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191216T033420Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T140000Z
DTEND:20200120T150500Z
DTSTAMP:20191226T230630Z
UID:7aeea9f0-07b4-4260-9f4e-8f83691b0377@conf.researchr.org
CREATED:20191205T052251Z
SUMMARY:[POPL TutorialFest] [T4] Proving Semantic Type Soundness in Iris - Derek Dreyer\, Robbert Krebbers\, Amin Timany
DESCRIPTION:In this tutorial we demonstrate how the Iris framework for concurrent separation logic can be used to prove type soundness of feature-rich\, realistic languages\, using the ``semantic approach'' to type soundness. Contrary to the traditional “syntactic approach” of progress and preservation\, the semantic approach has several advantages in terms of reasoning about data abstraction and unsafe features. We show that the semantic approach leads to clear and concise proofs that can be effectively mechanized using the implementation of Iris in the Coq proof assistant.
LOCATION:TutorialFest-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052258Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T140000Z
DTEND:20200120T150500Z
DTSTAMP:20191226T230630Z
UID:3f394bb8-653d-40d4-9153-60fe09c4c077@conf.researchr.org
CREATED:20191205T052246Z
SUMMARY:[POPL TutorialFest] [T5] Stateless Model Checking Algorithms and Tools for Strong and Weak Memory Models - Konstantinos (Kostis) Sagonas
DESCRIPTION:The aim of this tutorial is to review recent progress on algorithms for stateless model checking that try to combat the combinatorial explosion in the number of program executions that need to be explored to test and/or verify safety properties of concurrent programs running under both strong and weak memory models. \nSpecifically\, we will review state-of-the-art algorithms for dynamic partial order reduction (DPOR)\, compare their effectiveness\, present the various notions of optimality and bounding techniques that have been proposed in the literature\, and discuss how bounding and DPOR algorithms interact and why their combination is not trivial. Relevant tools of this area\, most notably Nidhugg\, will also be demonstrated. Finally\, we will briefly present some case studies on which these tools have been successfully applied.
LOCATION:TutorialFest-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052308Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T153000Z
DTEND:20200120T155500Z
DTSTAMP:20191226T230630Z
UID:33013802-de8b-41e9-b9f6-13d113d4fc2f@conf.researchr.org
CREATED:20191202T211800Z
SUMMARY:[PADL] Flexible Graph Matching and Graph Edit Distance Using Answer Set Programming - Sheung Chi Chan\, James Cheney
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T224004Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T155500Z
DTEND:20200120T162000Z
DTSTAMP:20191226T230630Z
UID:1db9a36e-e436-4fd1-8e54-2b6d422f2c37@conf.researchr.org
CREATED:20191202T211800Z
SUMMARY:[PADL] On Repairing Web Services Workflows - Thanh Hai Nguyen\, Enrico Pontelli\, Tran Cao Son
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T224012Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T162000Z
DTEND:20200120T170000Z
DTSTAMP:20191226T230630Z
UID:24e9c611-be15-42a4-a46b-9b7041ad0fbb@conf.researchr.org
CREATED:20191202T211800Z
SUMMARY:[PADL] Competitive Programming with PiCat - Neng-Fa Zhou
DESCRIPTION:Abstract: \nPicat (picat-lang.org) is a logic-based multi-paradigm programming language that integrates logic programming\, functional programming\, constraint programming\, and scripting. Picat takes many features from other languages\, including logic variables\, unification\, backtracking\, pattern-matching rules\, functions\, list/array comprehensions\, loops\, assignments\, tabling for dynamic programming and planning\, and constraint solving with CP (Constraint Programming)\, MIP (Mixed Integer Programming)\, SAT (Satisfiability)\, and SMT (SAT Modulo Theories). These features make Picat suitable for scripting and modeling. Picat has been used in programming competitions\, including ASP\, Prolog\, LP/CP\, and Google Code Jam. For competitive programming\, a language should be both expressive and efficient. With expressiveness\, algorithms and models can be coded concisely and within the allowed time limit. With efficiency of the language system\, programs can produce answers within the memory and time limits. I’ll report on the solutions in Picat to the five problems used in the 2019 LP/CP Programming Contest.[1] The problems are all combinatorial\, and all have practical application backgrounds\, including code deciphering\, resource allocation\, auto-programming\, game design\, and operations research optimization. The problems require different modeling techniques and solvers. One of the programs employs the CP module\, one uses the planner module\, and three others rely on the SAT module. These solutions well illustrate the use of Picat’s language constructs and solver tools\, and\, in hindsight\, demonstrate the fitness of Picat for competitive programming. For each problem\, I’ll give a problem description\, a program\, and the underlying techniques used by the program. I’ll also compare Picat\, as a general-purpose language\, with Prolog\, Haskell\, and Python\, and\, as a modeling language\, with ASP\, MiniZinc\, and AMPL.    [1] The solutions are available at: http://picat-lang.org/pc/lpcomp2019.html. I won the online track of the contest with these solutions.
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T183411Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T153500Z
DTEND:20200120T164000Z
DTSTAMP:20191226T230630Z
UID:e0f400b4-7a62-4ca5-bf7d-232dedcde810@conf.researchr.org
CREATED:20191221T200600Z
SUMMARY:[ADSL] Programs Synthesis with Separation Logic - Nadia Polikarpova
DESCRIPTION:In this talk I will present a program synthesizer SuSLik\, which accepts a separation logic specification as input\, and produces a provably safe program as output. SuSLik is the first synthesizer capable of generating a wide range of operations on linked data structures (such as singly- and doubly-linked lists\, sorted lists\, and trees) without additional hints form the user. To make this possible\, SuSLik relies on a novel proof system—synthetic separation logic—to derive correct-by-construction programs directly from their specifications.
LOCATION:ADSL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191221T200600Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T164000Z
DTEND:20200120T174500Z
DTSTAMP:20191226T230630Z
UID:babcc114-eb59-47f7-a6ed-b08cbbdd1894@conf.researchr.org
CREATED:20191221T200600Z
SUMMARY:[ADSL] Local Reasoning for Global Graph Properties - Thomas Wies
DESCRIPTION:Separation logics build on so-called separation algebras\, which allow expressing properties of heap regions such that modifications to a region do not invalidate properties stated about the remainder of the heap. This concept is key to enabling modular reasoning and also extends to concurrency. While heaps are naturally related to mathematical graphs\, many ubiquitous graph properties are non-local in character\, such as reachability between nodes\, path lengths\, acyclicity and other structural invariants\, as well as data invariants which combine with these notions. Reasoning modularly about such graph properties remains notoriously difficult\, since a local modification can have side-effects on a global property that cannot be easily confined to a small region. \nIn this talk\, we address the question: What separation algebra can be used to avoid proof arguments reverting back to tedious global reasoning in such cases? To this end\, we consider a general class of global graph properties expressed as fixpoints of algebraic equations over graphs. We present mathematical foundations for reasoning about this class of properties\, imposing minimal requirements on the underlying theory that allow us to define a suitable separation algebra. Building on this theory we develop a general proof technique for modular reasoning about global graph properties over program heaps\, in a way which can be integrated with existing separation logics. To demonstrate our approach\, we present preliminary work on automating local proofs for challenging examples such as a priority inheritance protocol\, the composite design pattern\, and overlaid data structures. This is joint work with Siddharth Krishna and Alexander J. Summers.
LOCATION:ADSL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191221T200600Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T153500Z
DTEND:20200120T155640Z
DTSTAMP:20191226T230630Z
UID:faec1d25-97af-472a-98b8-d35b73e22d74@conf.researchr.org
CREATED:20191212T192620Z
SUMMARY:[CPP] Verified Programming of Turing Machines in Coq - Yannick Forster\, Fabian Kunze\, Maximilian Wuttke
DESCRIPTION:We present a framework for the verified programming of multi-tape Turing machines in Coq. Improving on prior work by Asperti and Ricciotti in Matita\, we implement multiple layers of abstraction. The highest layer allows a user to implement nontrivial algorithms as Turing machines and verify their correctness\, as well as time and space complexity compositionally. The user can do so without ever mentioning states\, symbols on tapes or transition functions: They write programs in an imperative language with registers containing values of encodable data types\, and our framework constructs corresponding Turing machines. \nAs case studies\, we verify a translation from multi-tape to single-tape machines as well as a universal Turing machine\, both with polynomial time overhead and constant factor space overhead.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T155640Z
DTEND:20200120T161820Z
DTSTAMP:20191226T230630Z
UID:76e14e8c-3c4f-447c-88df-5d5090b6c1dd@conf.researchr.org
CREATED:20191212T192620Z
SUMMARY:[CPP] Inverting the Ackermann Hierarchy - Linh Tran\, Anshuman Mohan\, Aquinas Hobor
DESCRIPTION:We implement in Gallina a hierarchy of functions that calculate the upper inverses to the hyperoperation/Ackermann hierarchy. Our functions run in $\Theta(b)$ for inputs expressed in unary\, and in $O(b^2)$ for inputs expressed in binary (where $b$ = bitlength). We use our inverses to define linear-time functions—$\Theta(b)$ for both unary-represented and binary-represented inputs—that compute the upper inverse of the diagonal Ackermann function $\mathcal{A}(n)$. We show that these functions are consistent with the usual definition of the inverse Ackermann function $\alpha(n)$.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T161820Z
DTEND:20200120T164000Z
DTSTAMP:20191226T230630Z
UID:bac36bc3-2059-4d7b-b819-4caa533325ed@conf.researchr.org
CREATED:20191212T192620Z
SUMMARY:[CPP] Undecidability of Higher-Order Unification Formalised in Coq - Simon Spies\, Yannick Forster
DESCRIPTION:We formalise undecidability results concerning higher-order unification in the simply-typed $\lambda$-calculus with $\beta$-conversion in Coq. We prove the undecidability of general higher-order unification by reduction from Hilbert’s tenth problem\, the solvability of Diophantine equations\, following a proof by Dowek. We sharpen the result by establishing the undecidability of second-order and third-order unification following proofs by Goldfarb and Huet\, respectively. \nGoldfarb’s proof for second-order unification is by reduction from Hilbert’s tenth problem. Huet’s original proof uses the Post correspondence problem (PCP) to show the undecidability of third-order unification. We simplify and formalise his proof as a reduction from modified PCP. We also verify a decision procedure for first-order unification. \nAll proofs are carried out in the setting of synthetic undecidability and rely on Coq’s built-in notion of computation.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T153500Z
DTEND:20200120T160730Z
DTSTAMP:20191226T230630Z
UID:cb5aa5d1-02e1-46b3-ba6e-c759a97bd4ea@conf.researchr.org
CREATED:20191206T000436Z
SUMMARY:[VMCAI] Cheap CTL Compassion in NuSMV - Daniel Hausmann\, Tadeusz Litak\, Christoph Rauch\, Matthias Zinner
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T160730Z
DTEND:20200120T164000Z
DTSTAMP:20191226T230630Z
UID:b6b0a0c0-90fc-4f51-95a1-c696b0093b23@conf.researchr.org
CREATED:20191206T000436Z
SUMMARY:[VMCAI] A Cooperative Parallelization Approach for Property-Directed k-Induction - Martin Blicha\, Antti Hyvärinen\, Matteo Marescotti\, Natasha Sharygina
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T164000Z
DTEND:20200120T171230Z
DTSTAMP:20191226T230630Z
UID:b8785b39-be9c-40f4-835d-4aa47d58e156@conf.researchr.org
CREATED:20191206T000436Z
SUMMARY:[VMCAI] Mini Break
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T171230Z
DTEND:20200120T174500Z
DTSTAMP:20191226T230630Z
UID:abba38d9-05dc-4d09-a37d-af0b7d6ebcba@conf.researchr.org
CREATED:20191206T000436Z
SUMMARY:[VMCAI] Generalized Property-Directed Reachability for Hybrid Systems - Kohei Suenaga\, Takuya Ishizawa
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T153500Z
DTEND:20200120T173500Z
DTSTAMP:20191226T230630Z
UID:5ff94617-b9f4-4926-bb28-ded54199ee6d@conf.researchr.org
CREATED:20191205T051900Z
SUMMARY:[POPL TutorialFest] [T7] Programming and Reasoning with Kleene Algebra with Tests - Nate Foster\, Dexter Kozen\, Alexandra Silva
DESCRIPTION:Abstract \nKleene algebra with tests is an algebraic framework that can be used to reason about imperative programs. It has been applied across a wide variety of areas including program transformations\, concurrency control\, compiler optimizations\, cache control\, networking\, and more. \nThis tutorial will provide an overview of Kleene Algebra with Tests\, including the syntax\, semantics\, and the coalgebraic theory underlying decision procedures for program equivalence. We will illustrate how it can be used as a core frameworks for program verification\, including successful extensions and fundamental limitations. \nContext \nComputer scientists have long explored the connections between families of programming languages and abstract machines. This dual perspective has furnished deep theoretical insights as well as practical tools. As an example\, Kleene’s classic result establishing the equivalence of regular expressions and finite automata inspired decades of work across a variety of areas including programming language design\, mathematical semantics\, and formal verification. \nKleene Algebra with Tests (KAT)\, which combines Kleene Algebra (KA) with Boolean Algebra (BA)\, is a modern example of this approach. Viewed from the program-centric perspective\, a KAT models the fundamental constructs that arise in programs: sequencing\, branching\, iteration\, non-determinism\, etc. The equational theory of KAT enables algebraic reasoning and can be finitely axiomatized. Viewed from the machine-centric perspective\, a KAT describes a kind of automaton that generates a regular language of traces. This shift in perspective admits techniques from the theory of coalgebras for reasoning about program behavior. In particular\, there are efficient algorithms for checking bisimulation\, which can be optimized using properties of bisimulations or symbolic automata representations. \nKAT has been used to model computation across a wide variety of areas including program transformations\, concurrency control\, compiler optimizations\, cache control\, and more. A prominent recent application is NetKAT\, a language for reasoning about the packet-forwarding behavior of software-defined networks. NetKAT has a sound and complete equational theory\, and a coalgebraic decision procedure that can be used to automatically verify properties such as reachability\, loop-freedom\, and isolation. \nObjective \nThe objective of this tutorial is to provide attendees with a comprehensive introduction to Kleene Algebra with Tests (KAT) including techniques for using KAT to model and reason about computation in a variety of domains. \nTopics \nThe tutorial will cover the following topics: \n \n Basics: syntax\, denotational semantics\, axiomatization and decision procedure for Kleene Algebra and KAT. \n Applications: using KAT to establish the correctness of a program transformations including the Bohm-Jacopini theorem and the NetKAT to OpenFlow compiler. \n Extensions: systems obtained by enriching KAT with additional equations including NetKAT and KAT+B! \n Limits: fundamental limits on decidability and systems that go beyond the decidable fragment \n \nPresenters \nDexter Kozen is the Joseph Newton Pew\, Jr. Professor in Engineering\, at Cornell University. One of the fathers of dynamic logic and the Mu-calculus\, he is also credited for a number of major contributions in logic\, theory of computation\, automata theory and computational complexity. Dexter is a Fellow of the Association for Computing Machinery\, a Guggenheim Fellow\, and has received numerous awards\, including an Outstanding Innovation Award from IBM\, the EATCS award\, and the honor of a professorship at The Radboud Excellence Initiative\, in the Netherlands. \nNate Foster is an Associate Professor of Computer Science at Cornell University and a Principal Research Engineer at Barefoot Networks. The goal of his research is to develop languages and tools that make it easy for programmers to build secure and reliable systems. His current work focuses on the design and implementation of languages for programming software-defined networks. In the past he has also worked on bidirectional languages (also known as “lenses”)\, database query languages\, data provenance\, type systems\, mechanized proof\, and formal semantics. He received a PhD in Computer Science from the University of Pennsylvania. His honors include a Sloan Research Fellowship\, an NSF CAREER Award\, a Most Influential POPL Paper Award\, and the SIGCOMM Rising Star Award. \nAlexandra Silva is a Professor of Algebra\, Semantics\, and Computation at University College London. Her main research focuses on semantics of programming languages and modular development of algorithms for computational models. Much of her work uses the unifying perspective offered by coalgebra\, a mathematical framework established in the last decades. She was the recipient of the 2018 Needham Award\, 2017 Presburger Award\, 2016 Leverhulme Prize\, and 2015 ERC starting Grant.
LOCATION:TutorialFest-C -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T051911Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T153500Z
DTEND:20200120T173500Z
DTSTAMP:20191226T230630Z
UID:878ef53a-9bf3-4399-8902-6b5d98127eac@conf.researchr.org
CREATED:20191205T052258Z
SUMMARY:[POPL TutorialFest] [T4] Proving Semantic Type Soundness in Iris - Derek Dreyer\, Robbert Krebbers\, Amin Timany
DESCRIPTION:In this tutorial we demonstrate how the Iris framework for concurrent separation logic can be used to prove type soundness of feature-rich\, realistic languages\, using the ``semantic approach'' to type soundness. Contrary to the traditional “syntactic approach” of progress and preservation\, the semantic approach has several advantages in terms of reasoning about data abstraction and unsafe features. We show that the semantic approach leads to clear and concise proofs that can be effectively mechanized using the implementation of Iris in the Coq proof assistant.
LOCATION:TutorialFest-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052258Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T153500Z
DTEND:20200120T161000Z
DTSTAMP:20191226T230630Z
UID:e9242c68-c78f-4f9f-9453-e4e0986d0bf6@conf.researchr.org
CREATED:20191211T005145Z
SUMMARY:[PEPM] Frex: Free extensions for normalisation by evaluation (invited talk) - Ohad Kammar
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191211T005706Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T161000Z
DTEND:20200120T163500Z
DTSTAMP:20191226T230630Z
UID:4ebe23c6-5960-49bc-a55f-a4deba6d4847@conf.researchr.org
CREATED:20191211T005145Z
SUMMARY:[PEPM] Symbolic Bisimulation for Open and Parameterized System - Zechen Hou\, Eric Madelaine
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T025336Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T163500Z
DTEND:20200120T165000Z
DTSTAMP:20191226T230630Z
UID:c966f7a7-339e-4d85-8665-93c7ed260203@conf.researchr.org
CREATED:20191211T005145Z
SUMMARY:[PEPM] Mini Break 2
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191211T010107Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T165000Z
DTEND:20200120T172500Z
DTSTAMP:20191226T230630Z
UID:0fb7d439-d497-4726-98b7-4a6851d74bb7@conf.researchr.org
CREATED:20191211T005145Z
SUMMARY:[PEPM] Acumen: A Domain-Specific Language for Cyber-Physical Systems (invited talk) - Walid Taha
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191211T005856Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T172500Z
DTEND:20200120T174500Z
DTSTAMP:20191226T230630Z
UID:16da9ad7-b151-47ba-b2fe-29b2393fb5e4@conf.researchr.org
CREATED:20191211T005145Z
SUMMARY:[PEPM] An approach to generating text-based IDEs with syntax completion from syntax specification - Isao Sasano
DESCRIPTION:
LOCATION:PEPM -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T025137Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T153500Z
DTEND:20200120T173500Z
DTSTAMP:20191226T230630Z
UID:152120f0-bc74-4155-952e-9a67666d0aff@conf.researchr.org
CREATED:20191205T051822Z
SUMMARY:[POPL TutorialFest] [T5] Stateless Model Checking Algorithms and Tools for Strong and Weak Memory Models - Konstantinos (Kostis) Sagonas
DESCRIPTION:The aim of this tutorial is to review recent progress on algorithms for stateless model checking that try to combat the combinatorial explosion in the number of program executions that need to be explored to test and/or verify safety properties of concurrent programs running under both strong and weak memory models. \nSpecifically\, we will review state-of-the-art algorithms for dynamic partial order reduction (DPOR)\, compare their effectiveness\, present the various notions of optimality and bounding techniques that have been proposed in the literature\, and discuss how bounding and DPOR algorithms interact and why their combination is not trivial. Relevant tools of this area\, most notably Nidhugg\, will also be demonstrated. Finally\, we will briefly present some case studies on which these tools have been successfully applied.
LOCATION:TutorialFest-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191205T052308Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T165000Z
DTEND:20200120T171200Z
DTSTAMP:20191226T230630Z
UID:29a7e2cd-82e5-4095-9ec2-84e37b3cb2b2@conf.researchr.org
CREATED:20191212T193110Z
SUMMARY:[CPP] Cubical Synthetic Homotopy Theory - Anders Mörtberg\, Loïc Pujet
DESCRIPTION:Homotopy type theory is an extension of type theory that enables synthetic reasoning about spaces and homotopy theory. This has led to elegant computer formalizations of multiple classical results from homotopy theory. However\, many proofs are still surprisingly complicated to formalize. One reason for this is the axiomatic treatment of univalence and higher inductive types which complicates synthetic reasoning as many intermediate steps\, that could hold simply by computation\, require explicit arguments. Cubical type theory offers a solution to this in the form of a new type theory with native support for both univalence and higher inductive types. In this paper we show how the recent cubical extension of Agda can be used to formalize some of the major results of homotopy type theory in a direct and elegant manner.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T171200Z
DTEND:20200120T173400Z
DTSTAMP:20191226T230630Z
UID:43669926-80e7-40e5-8ccd-993cd4dfa2ea@conf.researchr.org
CREATED:20191212T193110Z
SUMMARY:[CPP] Three equivalent ordinal notation systems in Cubical Agda - Fredrik Nordvall Forsberg\, Chuangjie Xu\, Neil Ghani
DESCRIPTION:Ordinals and ordinal notation systems play an important role in program verification\, since they can be used to prove termination of programs. We present three ordinal notation systems representing ordinals below $\varepsilon_0$ in type theory\, using recent type-theoretical innovations such as mutual inductive-inductive definitions and higher inductive types. As case studies\, we show how basic ordinal arithmetic can be developed for these systems\, and how they admit a transfinite induction principle. We prove that all three notation systems are equivalent\, so that we can transport results between them using the univalence principle. All our constructions have been implemented in cubical Agda.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200120T173400Z
DTEND:20200120T175600Z
DTSTAMP:20191226T230630Z
UID:b328fc4d-f104-4a6a-b353-d7a7f044cc1e@conf.researchr.org
CREATED:20191212T193110Z
SUMMARY:[CPP] PC Chair's report - Cătălin Hriţcu\, Jasmin Blanchette
DESCRIPTION:
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T083000Z
DTEND:20200121T092000Z
DTSTAMP:20191226T230630Z
UID:0d3a7233-ca95-4df8-90fd-b9b092adbccc@conf.researchr.org
CREATED:20191202T211858Z
SUMMARY:[PADL] Invited Talk: Symbolic Reasoning About Machine Learning Systems - Adnan Darwiche
DESCRIPTION:Abstract: \nI will discuss a line of work in which we compile common machine learning systems into symbolic representations that have the same input-output behavior to facilitate formal reasoning about these systems. We have targeted Bayesian network classifiers\, random forests and some types of neural networks\, compiling each into tractable Boolean circuits\, including Ordered Binary Decision Diagrams (OBDDs). Once the machine learning system is compiled into a tractable Boolean circuit\, reasoning can commence using classical AI and computer science techniques. This includes generating explanations for decisions\, quantifying robustness and verifying properties such as monotonicity. I will particularly discuss a new theory for unveiling the reasons behind the decisions made by classifiers\, which can detect classifier bias sometimes from the reasons behind unbiased decisions. The theory is based on a new type of tractable circuits\, `Reason Circuits\,’ introduced specifically for this purpose. \nBiography: \nAdnan Darwiche is a professor and former chairman of the computer science department at UCLA. He directs the Automated Reasoning Group\, which focuses on probabilistic and symbolic reasoning and their applications to machine learning. Professor Darwiche is Fellow of AAAI and ACM. He is a former editor-in-chief of the Journal of Artificial Intelligence Research (JAIR) and author of “Modeling and Reasoning with Bayesian Networks\,” by Cambridge University Press. His group’s YouTube Channel can be found at: http://www.youtube.com/c/UCLAAutomatedReasoningGroup
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T182002Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T092000Z
DTEND:20200121T094500Z
DTSTAMP:20191226T230630Z
UID:9cb45478-f44b-402d-a20a-c139bc186129@conf.researchr.org
CREATED:20191202T211858Z
SUMMARY:[PADL] Exploiting Database Systems and Treewidth for Counting - Johannes K. Fichte\, Markus Hecher\, Patrick Thier\, Stefan Woltran
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T225650Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T094500Z
DTEND:20200121T100000Z
DTSTAMP:20191226T230630Z
UID:b242d1db-1548-47c9-8257-231f79193344@conf.researchr.org
CREATED:20191202T211858Z
SUMMARY:[PADL] Whitebox Induction of Default Rules Using High-Utility Itemset Mining - Farhad Shakerin\, Gopal Gupta
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T183505Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T090000Z
DTEND:20200121T100000Z
DTSTAMP:20191226T230630Z
UID:cc8dec54-21d7-4557-ada5-b669a4db8f81@conf.researchr.org
CREATED:20191220T155739Z
SUMMARY:[LAFI] Invited talk: Nonstandard Interpretation in Pyro - Fritz Obermeyer
DESCRIPTION:Probabilistic programming views randomized programs as model specifications. Whereas the standard interpretation of a randomized program is to generate data\, we instead focus on probabilistic inference as a nonstandard interpretation. Pyro uses multiple nonstandard interpretations and algebraic effects to create composable inference strategies\, thus enabling custom strategies for large complex models where naive inference is prohibitively slow. In this talk I will overview nonstandard interpretation and algebraic effects in probabilistic programming languages\, describe how effects are used to compose inference strategies in Pyro\, and finally describe an alternative perspective where approximate inference is accomplished via nonstandard interpretation of exact generative model descriptions.
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160110Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T090000Z
DTEND:20200121T100000Z
DTSTAMP:20191226T230630Z
UID:d0edd111-a561-40c3-9734-530d7d60200c@conf.researchr.org
CREATED:20191212T193434Z
SUMMARY:[CPP] Invited talk: Proof Assistants at the Hardware-Software Interface - Adam Chlipala
DESCRIPTION:Some of the earliest applications of proof assistants were to correctness of digital hardware designs\, but the subject doesn’t come up too frequently today at venues like CPP. I will try to make the case that proof assistants are a crucial tool for resolving both classical problems and new ones at the hardware-software interface. That is\, it is important to understand exactly what guarantees a processor exports to software\, it is important to verify that hardware exports those guarantees correctly\, and it is important to prove end-to-end theorems covering both hardware and software. A few social developments make this an exciting time to tackle these problems: open instruction sets and open-source hardware designs are growing in real-world relevance\, and surprising new classes of security vulnerabilities have gotten more practitioners thinking about precise hardware-software contracts. I will sketch the state of the research area and go into detail on a few of my own related projects. An ancillary goal is to convey that programming or proving digital hardware is a lot like programming or proving software\, with a few fun distinctions\, so more of the CPP crowd might want to give it a try!
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T090000Z
DTEND:20200121T091000Z
DTSTAMP:20191226T230630Z
UID:09bf2cf8-c2a6-43cc-9b75-923371ffc75a@conf.researchr.org
CREATED:20191215T210001Z
SUMMARY:[PLMW] Opening - Brigitte Pientka
DESCRIPTION:
LOCATION:PLMW -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191217T074647Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T091000Z
DTEND:20200121T100000Z
DTSTAMP:20191226T230630Z
UID:090bd2ec-c85d-4ab2-b7b3-4b7f6dbc034b@conf.researchr.org
CREATED:20191215T210001Z
SUMMARY:[PLMW] How to Write Papers So People Can Read Them - Derek Dreyer
DESCRIPTION:Learning to write well is an essential part of becoming a successful researcher. Unfortunately\, many researchers find it very hard to write well because they do not know how to view their text from the perspective of the reader. In this talk\, we present a simple set of principles for good writing\, based on an understanding of how readers process information. Unlike such platitudes as “Be clear” or “Omit needless words”\, our principles are constructive: one can easily check whether a piece of text satisfies them\, and if it does not\, the principles suggest concrete ways to improve it.
LOCATION:PLMW -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191217T151059Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T103000Z
DTEND:20200121T123000Z
DTSTAMP:20191226T230630Z
UID:2815fcb0-ead2-47d6-9afe-731f62f09305@conf.researchr.org
CREATED:20191116T140526Z
SUMMARY:[POPL Ally Skills Session] Ally Skills Session
DESCRIPTION:
LOCATION:Ally -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191116T143205Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T103000Z
DTEND:20200121T110000Z
DTSTAMP:20191226T230630Z
UID:d0546677-40ca-43bf-9327-d9daa7e0ed1a@conf.researchr.org
CREATED:20191220T160050Z
SUMMARY:[LAFI] A Differential-form Pullback Programming Language for Higher-order Reverse-mode Automatic Differentiation - Carol Mak\, C.-H. Luke Ong
DESCRIPTION:Building on the observation that reverse-mode automatic differentiation (AD)\, a generalisation of backpropagation\, can naturally be expressed as pullbacks of differential 1-forms\, we design a higher-order\, call-by-value functional programming language with a first-class reverse-mode AD operator. Using the category of convenient vector spaces and smooth maps\, we show that the operational semantics precisely captures reverse-mode AD\, even in a higher-order setting. We exhibit the connection with the differential λ-calculus via a translation that preserves reduction and interpretation.
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160148Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T110000Z
DTEND:20200121T113000Z
DTSTAMP:20191226T230630Z
UID:56f4e0ab-1fb4-4ea6-8798-759870c4fc7b@conf.researchr.org
CREATED:20191220T160050Z
SUMMARY:[LAFI] A Monad for Point Processes - Swaraj Dash\, Sam Staton
DESCRIPTION:A point process on a set is a random bag of elements of that set. In this extended abstract we explore programming with point processes in a monadic style. To this end we identify point processes on a set X with probability measures of bags of elements in X. We describe this view of point processes using the composition of the Giry and bag monads in the category Meas of measurable spaces and functions. We prove that this composition also forms a monad using the distributive law for monads.
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160148Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T113000Z
DTEND:20200121T120000Z
DTSTAMP:20191226T230630Z
UID:3f9acf3f-3b44-4abd-a1c2-78383c835d39@conf.researchr.org
CREATED:20191220T160050Z
SUMMARY:[LAFI] Denotational Semantics for Differentiable Programming with Manifolds - Jesse Sigal
DESCRIPTION:My work consists of denotational semantics for a first-order differentiable programming language which has smooth manifolds as ground types. It supports basic data types\, partiality\, conditionals\, and iteration. The typing judgments also tracks the differentiability class of terms. The semantics uses a family of restriction categories and a kind of lax functor between them. It also validates relations often used by automatic differentiation implementations.
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160148Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T120000Z
DTEND:20200121T123000Z
DTSTAMP:20191226T230630Z
UID:ddcb0c45-eea7-4d12-b3c3-b61c2b67caa8@conf.researchr.org
CREATED:20191220T160050Z
SUMMARY:[LAFI] Backpropagation in the Simply Typed Lambda-calculus with Linear Negation - Aloïs Brunel\, Damiano Mazza\, Michele Pagani
DESCRIPTION:Backpropagation is a classic automatic differentiation algorithm computing the gradient of functions specified by a certain class of simple\, first-order programs\, called computational graphs. It is a fundamental tool in several fields\, most notably machine learning\, where it is the key for efficiently training (deep) neural networks. Recent years have witnessed the quick growth of a research field called differentiable programming\, the aim of which is to express computational graphs more synthetically and modularly by resorting to actual programming languages endowed with control flow operators and higher-order combinators\, such as map and fold. In this paper\, we extend the backpropagation algorithm to a paradigmatic example of such a programming language: we define a compositional program transformation from the simply-typed lambda-calculus to itself augmented with a notion of linear negation\, and prove that this computes the gradient of the source program with the same efficiency as first-order backpropagation. The transformation is completely effect-free and thus provides a purely logical understanding of the dynamics of backpropagation. \n(This is a more detailed presentation of the POPL 2020 paper of the same title.)
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160148Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T103000Z
DTEND:20200121T105140Z
DTSTAMP:20191226T230630Z
UID:20f58f0c-74f1-4afa-84cf-0becae4c78bc@conf.researchr.org
CREATED:20191212T193418Z
SUMMARY:[CPP] Coq à la Carte - A Practical Approach to Modular Syntax with Binders - Yannick Forster\, Kathrin Stark
DESCRIPTION:The mechanisation of the meta-theory of programming languages is still considered hard and requires considerable effort. When formalising properties of the extension of a language\, one hence wants to reuse definitions and proofs. But type-theoretic proof assistants use inductive types and predicates to formalise syntax and type systems\, and these definitions are closed to extensions. Available approaches for modular syntax are either inapplicable to type theory or add a layer of indirectness by requiring complicated encodings of types. \nWe present a concise\, transparent\, and accessible approach to modular syntax with binders by adapting Swierstra’s Data Types à la Carte approach to the Coq proof assistant in an ad-hoc way. Our approach relies on two phases of code generation: We extend the Autosubst~2 tool and allow users to specify modular syntax with binders in a HOAS-like input language. To state and automatically compose modular functions and lemmas\, we implement commands based on MetaCoq. We support modular syntax\, functions\, predicates\, and theorems. \nWe demonstrate the practicality of our approach by modular proofs of preservation\, weak head normalisation\, and strong normalisation for several variants of mini-ML.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T105140Z
DTEND:20200121T111320Z
DTSTAMP:20191226T230630Z
UID:2432bfa6-57aa-4f67-8372-ceaff46ba1d0@conf.researchr.org
CREATED:20191212T193418Z
SUMMARY:[CPP] A Mechanized Formalization of GraphQL - Tomás Díaz\, Federico Olmedo\, Éric Tanter
DESCRIPTION:GraphQL is a novel language for specifying and querying web APIs\, allowing clients to flexibility and efficiently retrieve data of interest. The GraphQL language specification is unfortunately only available in prose\, making it hard to develop robust formal results for this language. Recently\, Hartig and Pérez proposed a formal semantics for GraphQL in order to study the complexity of GraphQL queries. This semantics is however not mechanized and leaves certain key aspects unverified. We present GraphCoQL\, the first mechanized formalization of GraphQL\, developed in the Coq proof assistant. GraphCoQL covers the schema definition DSL\, query definitions\, validation of both schema and queries\, as well as the semantics of queries over a graph data model. We illustrate the application of GraphCoQL by formalizing the key query transformation and interpretation techniques of Hartig and Pérez\, and proving them correct\, after addressing some imprecisions and minor issues. We hope that GraphCoQL can serve as a solid formal baseline for both language design and verification efforts for GraphQL.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191222T155945Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T111320Z
DTEND:20200121T113500Z
DTSTAMP:20191226T230630Z
UID:9f51d3ed-9224-4348-9d4b-693ece91c960@conf.researchr.org
CREATED:20191212T193418Z
SUMMARY:[CPP] ConCert: A Smart Contract Certification Framework in Coq - Danil Annenkov\, Jakob Botsch Nielsen\, Bas Spitters
DESCRIPTION:We present a new way of embedding functional languages into the Coq proof assistant by using meta-programming. This allows us to develop the meta-theory of the language using the deep embedding and provides a convenient way for reasoning about concrete programs using the shallow embedding. We connect the deep and the shallow embeddings by a soundness theorem. As an instance of our approach\, we develop an embedding of a core smart contract language into Coq and verify several important properties of a crowdfunding contract based on a previous formalization of smart contract execution in blockchains.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T163141Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T103000Z
DTEND:20200121T111000Z
DTSTAMP:20191226T230630Z
UID:e19428ec-3330-4bfd-b46c-bf64dfa8a171@conf.researchr.org
CREATED:20191215T210138Z
SUMMARY:[PLMW] Making Progress Under Uncertainty in SMT Solving\, Research\, and Life - Lindsey Kuper
DESCRIPTION:SAT and Satisfiability Modulo Theories (SMT) solvers have many important applications in PL\, including verification\, testing\, type checking and inference\, and program analysis – but they are often a mysterious black box to their users\, even when those users are PL researchers with lots of solver experience! This talk will be partly a tutorial introduction to the inner workings of SAT and SMT solvers\, and partly an extended analogy to navigating life as a researcher: making decisions when you have only incomplete information to go on\, learning from decisions that turned out to be bad\, and determining when to give up and when to try again. I’ll also highlight a variety of papers in this year’s POPL program that make use of SAT and SMT solving\, and discuss why I think it’s worthwhile to learn about solver internals.
LOCATION:PLMW -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191217T074559Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T111000Z
DTEND:20200121T115000Z
DTSTAMP:20191226T230630Z
UID:861c004d-4b85-4d1c-80c6-57050a0e7711@conf.researchr.org
CREATED:20191215T210138Z
SUMMARY:[PLMW] Research as a collaborative effort - Marco Gaboardi
DESCRIPTION:As society becomes more and more connected\, so does research. Research in computer science is changing\, becoming more collaborative and open than it was before. The problems that computer science focuses on today have larger impact on society and on the everyday life of individuals. The programming languages community as a whole has tremendous opportunities to contribute in a positive way to this impact. However\, these opportunities often require the combined effort of different groups and communities\, organized as large collaborative efforts. This approach often contrasts with the needs that young researchers have of building their own research agenda. In this talk\, starting from my personal experience\, I will discuss some advice on how to survive in collaborative research.
LOCATION:PLMW -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191215T230943Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T115000Z
DTEND:20200121T123000Z
DTSTAMP:20191226T230630Z
UID:f550928a-ccd4-41d1-be0a-c601aa3e694c@conf.researchr.org
CREATED:20191215T210138Z
SUMMARY:[PLMW] Theorem provers are a P.L. researcher's best friend - Xavier Leroy
DESCRIPTION:Interactive and automated theorem proving are increasingly used in programming language research. I will discuss why this machine assistance is useful\, and how it enables a quantitative jump in the complexity of the P.L. artifacts that can be formalized and in the confidence we can have in these formalizations. The talk will include a short demo of the Coq proof assistant.
LOCATION:PLMW -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191215T231011Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T103000Z
DTEND:20200121T110000Z
DTSTAMP:20191226T230630Z
UID:799411a6-8419-46da-8c02-6ad148af0e8c@conf.researchr.org
CREATED:20191206T000448Z
SUMMARY:[VMCAI] Language Inclusion for Finite Prime Event Structures - Andreas Fellner\, Thorsten Tarrach\, Georg Weissenbacher
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T110000Z
DTEND:20200121T113000Z
DTSTAMP:20191226T230630Z
UID:74a605db-e046-454f-9093-c129936a0f0c@conf.researchr.org
CREATED:20191206T000448Z
SUMMARY:[VMCAI] Promptness and Bounded Fairness in Concurrent and Parameterized Systems - Swen Jacobs\, Mouhammad Sakr\, Martin Zimmermann
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T113000Z
DTEND:20200121T120000Z
DTSTAMP:20191226T230630Z
UID:b777ee5a-369f-44b7-a7c2-11b36c582cf8@conf.researchr.org
CREATED:20191206T000448Z
SUMMARY:[VMCAI] Mini Break
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T120000Z
DTEND:20200121T123000Z
DTSTAMP:20191226T230630Z
UID:1d8f54b6-4a14-4f07-9e53-88c3e504c3e7@conf.researchr.org
CREATED:20191206T000448Z
SUMMARY:[VMCAI] Solving LIA* Using Approximations - Maxwell Levatich\, Nikolaj Bjørner\, Ruzica Piskac\, Sharon Shoham
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T103000Z
DTEND:20200121T105500Z
DTSTAMP:20191226T230630Z
UID:7b268cfa-68c3-4d2c-ae09-db53a29956b2@conf.researchr.org
CREATED:20191202T211854Z
SUMMARY:[PADL] Explanations for Dynamic Programming - Martin Erwig\, Prashant Kumar\, Alan Fern
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T224135Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T105500Z
DTEND:20200121T112000Z
DTSTAMP:20191226T230630Z
UID:5b79b1eb-f774-4a6a-9183-aad9937499cc@conf.researchr.org
CREATED:20191202T211854Z
SUMMARY:[PADL] A DSL for Integer Range Reasoning: Partition\, Interval and Mapping Diagrams - Johannes Eriksson\, Masoumeh Parsa
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T224145Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T112000Z
DTEND:20200121T113500Z
DTSTAMP:20191226T230630Z
UID:2a8e7662-515f-4bd9-a279-24c99c6a6d1a@conf.researchr.org
CREATED:20191202T211854Z
SUMMARY:[PADL] Variability-aware Datalog - Ramy Shahin\, Marsha Chechik
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T224157Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T113500Z
DTEND:20200121T120000Z
DTSTAMP:20191226T230630Z
UID:ef877368-9551-441e-9ac6-caf3b64042ab@conf.researchr.org
CREATED:20191202T211854Z
SUMMARY:[PADL] Panel: Reasoning for machine learning at large - Adnan Darwiche\, Johannes K. Fichte\, Markus Hecher\, Patrick Thier\, Stefan Woltran\, Farhad Shakerin\, Gopal Gupta\, Martin Erwig\, Prashant Kumar\, Alan Fern\, Johannes Eriksson\, Masoumeh Parsa\, Ramy Shahin\, Marsha Chechik
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T224211Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T114500Z
DTEND:20200121T120730Z
DTSTAMP:20191226T230630Z
UID:a10dd09c-b1ad-43d2-a81d-78b0b6e798ed@conf.researchr.org
CREATED:20191212T193411Z
SUMMARY:[CPP] Formalising Oblivious Transfer in the Semi-Honest and Malicious Model in CryptHOL - David Butler\, David Aspinall\, Adria Gascon
DESCRIPTION:Large scale implementations of Multi-Party Computation (MPC) protocols are becoming practical. Thus it is important to have strong guarantees for the whole development process\, from the underlying cryptography to the implementation. Computer aided proofs are a way to provide such guarantees. \nWe use CryptHOL to formalise a general framework for reasoning about proofs of security of MPC. In particular we first consider protocols for 1-out-of-2 Oblivious Transfer ($OT^1_2$) — a fundamental MPC protocol — in both the semi-honest and malicious models. We then extend our semi-honest formalisation to $OT^1_4$ which is a building block for our proof of security for the GMW protocol. \nThe semi-honest $OT^1_2$ protocol we formalise is constructed from Extended Trapdoor Permutations (ETP)\, we first prove the general construction secure and then instantiate for the RSA collection. Our general proof assumes only the existence of ETPs\, meaning any instantiated results come without needing to prove any security properties\, only that the requirements of an ETP are met.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T235612Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T120730Z
DTEND:20200121T123000Z
DTSTAMP:20191226T230630Z
UID:adb43a40-151f-40cd-beaf-8f48a62eed71@conf.researchr.org
CREATED:20191212T193411Z
SUMMARY:[CPP] Verified Security of BLT Signature Scheme - Denis Firsov\, Ahto Buldas\, Ahto Truu\, Risto Laanoja
DESCRIPTION:The majority of real-world applications of digital signatures use timestamping to ensure non-repudiation in face of possible key revocations. This observation led Buldas\, Laanoja\, and Truu to a server-assisted digital signature scheme built around cryptographic timestamping. In this paper\, we report on the machine-checked proofs of existential unforgeability under the chosen-message attack (EUF-CMA) of some variations of BLT digital signature scheme. The proofs are developed and verified using the EasyCrypt framework\, which provides interactive theorem proving supported by the state-of-the-art SMT solvers.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T123000Z
DTEND:20200121T140000Z
DTSTAMP:20191226T230630Z
UID:2dce70dc-5694-4d92-a383-fab294e0d577@conf.researchr.org
CREATED:20191128T065504Z
SUMMARY:[POPL Catering] Lunch
DESCRIPTION:Lunch
LOCATION:Lunch Room -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191128T065511Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T133000Z
DTEND:20200121T140000Z
DTSTAMP:20191226T230630Z
UID:f3ff2584-8f2c-47da-8b08-341025bd3282@conf.researchr.org
CREATED:20191203T203300Z
SUMMARY:[PADL] Invited Talk: Relational Artificial Intelligence - Molham Aref
DESCRIPTION:Abstract: \nIn this talk\, I will make the case for a first-principles approach to machine learning over relational databases that exploits recent development in database systems and theory. The input to learning classification and regression models is defined by feature extraction queries over relational databases. The mainstream approach to learning over relational data is to materialize the results of the feature extraction query\, export it out of the database\, and then learn over it using statistical software packages. These three steps are expensive and unnecessary. Instead\, one can cast the machine learning problem as a database problem\, keeping the feature extraction query unmaterialized and using a new generation of meta-algorithms to push the learning through the query. The performance of this approach benefits tremendously from structural properties of the relational data and of the feature extraction query\; such properties may be algebraic (semi-ring)\, combinatorial (hypertree width)\, or statistical (sampling). Performance is further improved by leveraging recent advances in compiler technology that eliminate the cost of abstraction and allows us to specialize the computation for specific workloads and datasets. This translates to several orders-of-magnitude speed-up over state-of-the-art systems. \nThis work is done by my colleagues at RelationalAI and by members of our faculty research network\, including Dan Olteanu (Oxford)\, Maximilian Schleich (Oxford)\, Ben Moseley (CMU)\, and XuanLong Nguyen (Michigan). \nBiography: \nMolham Aref is the Chief Executive Officer of RelationalAI. He has more than 28 years of experience in leading organisations that develop and implement high value machine learning and artificial intelligence solutions across various industries. Prior to RelationalAI he was CEO of LogicBlox and Predictix (now Infor)\, Optimi (now Ericsson)\, and co-founder of Brickstream (now FLIR). Molham held senior leadership positions at HNC Software (now FICO) and Retek (now Oracle).
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T182121Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T140000Z
DTEND:20200121T143000Z
DTSTAMP:20191226T230630Z
UID:dc176961-8e7e-445a-b01b-b42847fdf501@conf.researchr.org
CREATED:20191203T203300Z
SUMMARY:[PADL] Invited Talk: Learning Interpretable Rules from Structured Data - Mayur Naik
DESCRIPTION:Abstract: \nThe problem of learning interpretable rules from structured data has important theoretical and practical ramifications in the fields of machine learning and program synthesis. Datalog\, a declarative logic programming language\, has emerged as a popular medium for studying this problem due to its rich expressivity and scalable performance. I will present search-based and constraint-solving techniques to learn Datalog programs from relational input-output data. The techniques address previously open problems as well as pose new challenges\, spanning data-efficient learning\, tolerating noise\, supporting expressive features of Datalog\, learning without syntactic bias\, and scaling to very large search spaces. \nBiography: \nMayur Naik is an Associate Professor of Computer and Information Science at the University of Pennsylvania. His research spans programming languages related topics with the overarching goal of making software better\, safer\, and easier to build and maintain. His current focus concerns developing scalable techniques to reason about programs by combining machine learning and formal methods. He is also interested in foundations and applications of neuro-symbolic approaches that synergistically combine deep learning and symbolic reasoning. He received a Ph.D. in Computer Science from Stanford University in 2008. Previously\, he was a researcher at Intel Labs\, Berkeley from 2008 to 2011\, and a faculty member at Georgia Tech from 2011 to 2016.
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T182826Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T143000Z
DTEND:20200121T150000Z
DTSTAMP:20191226T230630Z
UID:c41439c5-ef86-47ad-910a-d94486ce6a80@conf.researchr.org
CREATED:20191203T203300Z
SUMMARY:[PADL] Invited Talk: An Introduction to the Imandra Automated Reasoning System - Grant Passmore
DESCRIPTION:Abstract: \nImandra (imandra.ai) is a cloud-native automated reasoning system powering a suite of tools for the design and regulation of complex algorithms. Imandra is finding exciting industrial use: For example\, Goldman Sachs is now public with the fact that Imandra is used to design and audit some of their most complex trading algorithms. \nFoundationally\, Imandra is a full-featured interactive theorem prover with a unique combination of features\, including: an “executable” logic based on a (pure\, higher-order) subset of OCaml (in much the same way that ACL2’s logic is based on a subset of Lisp)\, first-class computable counterexamples (with a proof procedure that is “complete for counterexamples” in a precise sense)\, a seamless integration of bounded model checking and full-fledged theorem proving\, decision procedures for nonlinear real and floating point arithmetic\, first-class state-space decompositions\, and powerful techniques for automated induction (including the “lifting” of many Boyer-Moore ideas to our typed\, higher-order setting). \nIn this talk\, I’ll give an overview of Imandra and we’ll together work many examples. You can follow along and experiment with Imandra in the browser at http://try.imandra.ai/ and install Imandra locally by following the instructions at http://docs.imandra.ai/. \nBiography: \nGrant Passmore is co-founder and co-CEO of Imandra Inc. (imandra.ai) where he leads the development of the Imandra automated reasoning system. Grant is a widely published researcher in formal verification and symbolic AI\, with work ranging from nonlinear decision procedures in SMT to the analysis of fairness and regulatory compliance of financial algorithms. He has been a key contributor to safety verification of algorithms at Cambridge\, Carnegie Mellon\, Edinburgh\, Microsoft Research and SRI. He earned his PhD from the University of Edinburgh\, is a graduate of UT Austin (BA in Mathematics) and the Mathematical Research Institute in the Netherlands (Master Class in Mathematical Logic)\, and is a Life Member of Clare Hall\, University of Cambridge.
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T182436Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T140000Z
DTEND:20200121T150500Z
DTSTAMP:20191226T230630Z
UID:3951b69c-6d17-4608-be0e-ae36202b7b0c@conf.researchr.org
CREATED:20191215T210426Z
SUMMARY:[PLMW] Panel - William J. Bowman\, Kenny Foner\, Andrew Hirsch\, Taro Sekiyama\, Juliana Franco\, Hannah Gommerstadt
DESCRIPTION:
LOCATION:PLMW -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191215T230937Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T140000Z
DTEND:20200121T143230Z
DTSTAMP:20191226T230630Z
UID:a07cc640-0cb3-465f-89fc-17511c2d870c@conf.researchr.org
CREATED:20191220T160151Z
SUMMARY:[LAFI] Divide\, Conquer\, and Combine: a New Inference Strategy for Probabilistic Programs with Stochastic Support - Yuan Zhou\, Hongseok Yang\, Yee Whye Teh\, Tom Rainforth
DESCRIPTION:Universal probabilistic programming systems (PPSs) provide a powerful framework for specifying rich and complex probabilistic models. However\, it comes at the cost of substantially complicating the process of drawing inferences from the model. In particular\, inference can become challenging when the support of the model varies between executions. Though general-purpose inference engines have been designed to operate in such settings\, they are typically inefficient\, often relying on proposing from the prior to make transitions. To address this\, we introduce a new inference framework: Divide\, Conquer\, and Combine (DCC). DCC divides the program into separate straight line sub-programs\, each of which has a fixed support allowing more powerful inference algorithms to be run locally\, before recombining their outputs in a principled fashion. We show how DCC can be implemented as an automated and general-purpose PPS inference engine\, and empirically confirm that it can provide substantial performance improvements over previous approaches.
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160209Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T143230Z
DTEND:20200121T150500Z
DTSTAMP:20191226T230630Z
UID:42aaf726-b949-4c10-9489-b1c1c70c0141@conf.researchr.org
CREATED:20191220T160151Z
SUMMARY:[LAFI] Gen and MetaGen - Austin Garrett\, Alexander K. Lew\, Benjamin Sherman\, Ben Zinberg\, Michael Carbin\, Marco Cusumano-Towner\, Vikash Mansinghka
DESCRIPTION:TBD
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160209Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T140000Z
DTEND:20200121T142140Z
DTSTAMP:20191226T230630Z
UID:70ca7792-48f7-4cfc-ac99-00640927ffd6@conf.researchr.org
CREATED:20191212T193548Z
SUMMARY:[CPP] Formalizing Determinacy of Concurrent Revisions - Roy Overbeek
DESCRIPTION:Concurrent revisions is a concurrency control model designed to guarantee \emph{determinacy}\, meaning that the outcomes of programs are uniquely determined. This paper describes an Isabelle/HOL formalization of the model’s operational semantics and proof of determinacy. We discuss and resolve subtle ambiguities in the operational semantics and simplify the proof of determinacy. Although our findings do not appear to correspond to bugs in implementations\, the formalization highlights some of the challenges involved in the design and verification of concurrency control models.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191224T200216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T142140Z
DTEND:20200121T144320Z
DTSTAMP:20191226T230630Z
UID:a5b818c1-c224-4c4e-84e4-64815aeb5f09@conf.researchr.org
CREATED:20191212T193548Z
SUMMARY:[CPP] Formalizing π-calculus in Guarded Cubical Agda - Niccolò Veltri\, Andrea Vezzosi
DESCRIPTION:Dependent type theories with guarded recursion have shown themselves suitable for the development of denotational semantics of programming languages. In particular Ticked Cubical Type Theory (TCTT) has been used to show that for guarded labelled transition systems (GLTS) interpretation into the denotational semantics maps bisimilar processes to equal values. In fact the two notions are proved equivalent\, allowing one to reason about equality in place of bisimilarity. \nWe extend that result to the $\pi$-calculus\, picking early congruence as the syntactic notion of equivalence between processes\, showing that denotational models based on guarded recursive types can handle the dynamic creation of channels that goes beyond the scope of GLTSs. \nHence we present a fully abstract denotational model for the early $\pi$-calculus\, formalized as an extended example for Guarded Cubical Agda: a novel implementation of Ticked Cubical Type Theory based on Cubical Agda.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T144320Z
DTEND:20200121T150500Z
DTSTAMP:20191226T230630Z
UID:1ad932e8-69e1-444f-9a66-0bb9c668fc7f@conf.researchr.org
CREATED:20191212T193548Z
SUMMARY:[CPP] Intrinsically-Typed Definitional Interpreters for Linear\, Session-Typed Languages - Arjen Rouvoet\, Casper Bach Poulsen\, Robbert Krebbers\, Eelco Visser
DESCRIPTION:An intrinsically-typed definitional interpreter is an attractive way of specifying the dynamic semantics of a programming language. It is a concise specification that is executable and type safe by construction. Unfortunately\, scaling up intrinsically-typed definitional interpreters to more complicated object languages often results in definitions that are cluttered with manual proof work. In linearly-typed languages (e.g.\, session-typed languages) one has to ensure that all values are used linearly\, and that linearity is maintained throughout the definition of the interpreter. \nWe present new methods and tools that make it possible to implement intrinsically-typed definitional interpreters for linearly-typed languages in a way that hides the majority of the manual proof work. Inspired by separation logic\, we develop reusable and composable abstractions for programming with linear operations using dependent types. We use these abstractions to define interpreters for linearly-typed lambda calculi with strong references\, and concurrent\, session-typed communication in Agda.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T215215Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T140000Z
DTEND:20200121T143230Z
DTSTAMP:20191226T230630Z
UID:6159f2a7-2921-4b55-9652-73e07a526452@conf.researchr.org
CREATED:20191205T235131Z
SUMMARY:[VMCAI] Formalizing and Checking Multilevel Consistency - Ahmed Bouajjani\, Constantin Enea\, Madhavan Mukund\, Gautham Shenoy R\, S.P. Suresh
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191221T120526Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T143230Z
DTEND:20200121T150500Z
DTSTAMP:20191226T230630Z
UID:90928b9e-9dd4-4c68-ae22-999aaa36ff15@conf.researchr.org
CREATED:20191205T235131Z
SUMMARY:[VMCAI] Practical Abstractions for Automated Verification of Shared-Memory Concurrency - Wytse Oortwijn\, Dilian Gurov\, Marieke Huisman
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T153000Z
DTEND:20200121T160000Z
DTSTAMP:20191226T230630Z
UID:a7199b2e-c5c1-4093-9430-a5919f3b6072@conf.researchr.org
CREATED:20191203T063126Z
SUMMARY:[PADL] Invited Talk: We Are All Poor Schmucks: On the Value of Gradual Types - Philip Wadler
DESCRIPTION:Abstract: \nI always assumed gradual types were to help those poor schmucks using untyped languages to migrate to typed languages. I now realise that I am one of the poor schmucks. Much interest within the programming language community now centres on systems such as session types\, effect types\, and dependent types\, which are not currently available in any widely-used language. To support migration from legacy code to code with these exotic type systems\, some form of gradual typing appears essential. \n(Adapted from A Complement to Blame\, Philip Wadler\, SNAPL 2015.) \nBiography: \nPhilip Wadler is Professor of Theoretical Computer Science at the University of Edinburgh and Senior Research Fellow at IOHK. He is an ACM Fellow and a Fellow of the Royal Society of Edinburgh\, past chair of ACM SIGPLAN\, past holder of a Royal Society-Wolfson Research Merit Fellowship\, and winner of the SIGPLAN Distinguished Service Award and the POPL Most Influential Paper Award. Previously\, he worked or studied at Stanford\, Xerox Parc\, CMU\, Oxford\, Chalmers\, Glasgow\, Bell Labs\, and Avaya Labs\, and visited as a guest professor in Copenhagen\, Sydney\, and Paris. He has an h-index of 70 with more than 25\,000 citations to his work\, according to Google Scholar. He contributed to the designs of Haskell\, Java\, and XQuery\, and is a co-author of Introduction to Functional Programming (Prentice Hall\, 1988)\, XQuery from the Experts (Addison Wesley\, 2004)\, Generics and Collections in Java (O’Reilly\, 2006)\, and Programming Language Foundations in Agda (2018). He has delivered invited talks in locations ranging from Aizu to Zurich.
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T182728Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T160000Z
DTEND:20200121T164500Z
DTSTAMP:20191226T230630Z
UID:c9b304dc-9de6-4ed8-b752-f33d542a68e8@conf.researchr.org
CREATED:20191203T063126Z
SUMMARY:[PADL] Panel: Experience and Direction - Molham Aref\, Mayur Naik\, Grant Passmore\, Philip Wadler
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T224312Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T164500Z
DTEND:20200121T170000Z
DTSTAMP:20191226T230630Z
UID:f454e7c3-a349-45de-8b7a-b678a093ad52@conf.researchr.org
CREATED:20191203T063126Z
SUMMARY:[PADL] Closing
DESCRIPTION:
LOCATION:PADL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191203T224320Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T154000Z
DTEND:20200121T164000Z
DTSTAMP:20191226T230630Z
UID:96b87564-d0fd-4f95-951a-f615d5bca318@conf.researchr.org
CREATED:20191215T210255Z
SUMMARY:[PLMW] How Can I Academia When My Brain Can't Even? Mental Health in Grad School and Beyond - Kenny Foner
DESCRIPTION:
LOCATION:PLMW -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191216T141426Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T164000Z
DTEND:20200121T165000Z
DTSTAMP:20191226T230630Z
UID:6cb8cd44-3015-46b2-9505-c7b38fd006cb@conf.researchr.org
CREATED:20191215T210255Z
SUMMARY:[PLMW] Mini break
DESCRIPTION:
LOCATION:PLMW -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191215T230927Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T165000Z
DTEND:20200121T173500Z
DTSTAMP:20191226T230630Z
UID:13ef9125-5ac6-487f-90f4-200ecdbcfba2@conf.researchr.org
CREATED:20191215T210255Z
SUMMARY:[PLMW] Automated Program Verification using Abductive Reasoning - Isil Dillig
DESCRIPTION:Deductive program verification tools based on Floyd-Hoare logic prove program safety by generating verification conditions (VCs) and proving the validity of these VCs using an automated theorem prover. While this process is mostly automatic\, deductive verifiers typically rely on program annotations (e.g.\, loop invariants) to generate verification conditions. In this talk\, we will describe how abductive reasoning can be used to automatically infer relevant program annotations. Specifically\, we will talk about logical abduction and how it can be combined with backtracking search to automatically generate loop invariants that are necessary for proving program safety.
LOCATION:PLMW -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191215T230922Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T153500Z
DTEND:20200121T160500Z
DTSTAMP:20191226T230630Z
UID:eb04bfbd-8be7-452f-af13-df8079c61847@conf.researchr.org
CREATED:20191220T160505Z
SUMMARY:[LAFI] Coinductive Trees for Exact Inference of Probabilistic Programs - Alexander Bagnall\, Gordon Stewart\, Anindya Banerjee
DESCRIPTION:We propose a coinductive variant of Knuth-Yao trees (variously\, Discrete Distribution Generating trees) as an intermediate representation supporting exact inference for probabilistic programs which may contain loops with probabilistic termination conditions. We provide a prototype implementation of a probabilistic programming language\, Zar\, written in Haskell\, exemplifying both Knuth-Yao trees as well as exact inference on the trees.
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160552Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T160500Z
DTEND:20200121T163500Z
DTSTAMP:20191226T230630Z
UID:0a4b1cfe-8464-40cb-adcf-3391edd9abd0@conf.researchr.org
CREATED:20191220T160505Z
SUMMARY:[LAFI] Name generation and Higher-order Probabilistic Programming (Or is new=rnd?) - Dario Stein\, Sam Staton
DESCRIPTION:We illustrate the close connections between name generation and probabilistic programming. By interpreting name generation as random sampling\, we obtain a new denotational semantics for name generation. Using a novel analysis of distributions on function spaces\, we can show that this semantics is actually very fine-grained.
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160553Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T163500Z
DTEND:20200121T170500Z
DTSTAMP:20191226T230630Z
UID:2f6245aa-bbd9-4b60-9dd1-c076d54ae757@conf.researchr.org
CREATED:20191220T160505Z
SUMMARY:[LAFI] Density Functions of Statistical Probabilistic Programs - Tom Mattinson\, C.-H. Luke Ong
DESCRIPTION:We present a transformer that takes a first order probabilistic program and returns a density function corresponding to this program. Alongside this we also present a type system that identifies the distributions these programs represent as absolutely continuous. These absolutely continuous distributions are precisely those that admit density functions. This work includes analysis on programs with both scoring con- structs and unbounded loops.
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160553Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T170500Z
DTEND:20200121T173500Z
DTSTAMP:20191226T230630Z
UID:547e2f3a-e9ab-46d9-9d3d-fc3c5c77a809@conf.researchr.org
CREATED:20191220T160505Z
SUMMARY:[LAFI] Probabilistic Programming around Gaussian Processes - David Tolpin
DESCRIPTION:We present GoGP\, a library for probabilistic programming around Gaussian processes. Kernels\, beliefs about hyperparameters and about observation inputs and outputs are programmatically expressed using the same differentiable probabilistic programming framework. On one hand\, a basic usage with maximum-likelihood hyperparameter estimates and homoscedastic Gaussian noise requires as little coding as with any Gaussian process library. On the other hand\, imposing prior beliefs on hyperparameters\, handling input uncertainty\, heteroscedastic and non-Gaussian noise\, or change point detection can be organically added on top of a Gaussian process kernel. Just like distributions in probabilistic programs\, kernels can be flexibly combined using general code flow rather than through predefined combination operators (usually addition and multiplication). Implemented in Go\, a general-purpose programming language popular for server-side programming\, our library is both well suited for integration into data processing/machine learning pipelines and exploits language features such as efficient light-weight parallelism for computation efficiency. We demonstrate different uses of the library on a variety of case studies inspired by applications.
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160554Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T173500Z
DTEND:20200121T174500Z
DTSTAMP:20191226T230630Z
UID:217265f2-866b-43b8-99a2-9c29ea83a1f4@conf.researchr.org
CREATED:20191220T160505Z
SUMMARY:[LAFI] Closing
DESCRIPTION:
LOCATION:LAFI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191220T160555Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T153500Z
DTEND:20200121T155640Z
DTSTAMP:20191226T230630Z
UID:da46a27b-cef0-41a5-8031-88855d724b9d@conf.researchr.org
CREATED:20191212T193803Z
SUMMARY:[CPP] Formalising perfectoid spaces - Patrick Massot\, Kevin Buzzard\, Johan Commelin
DESCRIPTION:Perfectoid spaces are sophisticated objects in arithmetic geometry introduced by Peter Scholze in 2012. We formalised enough definitions and theorems in topology\, algebra and geometry to define perfectoid spaces in the Lean theorem prover. This experiment confirms that a proof assistant can handle complexity in that direction\, which is rather different from formalising a long proof about simple objects. It also confirms that mathematicians with no computer science training can become proficient users of a proof assistant in a relatively short period of time. Finally\, we observe that formalising a piece of mathematics that is a trending topic boosts the visibility of proof assistants amongst pure mathematicians.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T155640Z
DTEND:20200121T161820Z
DTSTAMP:20191226T230630Z
UID:25be4306-1849-47de-99ef-6ae527c126a4@conf.researchr.org
CREATED:20191212T193803Z
SUMMARY:[CPP] A Constructive Formalization of the Weak Perfect Graph Theorem - Abhishek Kr Singh\, Raja Natarajan
DESCRIPTION:The Perfect Graph Theorems are important results in graph theory describing the relationship between clique number $\omega(G) $ and chromatic number $\chi(G) $ of a graph $G$. A graph $G$ is called \emph{perfect} if $\chi(H)=\omega(H)$ for every induced subgraph $H$ of $G$. The Strong Perfect Graph Theorem (SPGT) states that a graph is perfect if and only if it does not contain an odd hole (or an odd anti-hole) as its induced subgraph. The Weak Perfect Graph Theorem (WPGT) states that a graph is perfect if and only if its complement is perfect. In this paper\, we present a formal framework for working with finite simple graphs. We model finite simple graphs in the Coq Proof Assistant by representing its vertices as a finite set over a countably infinite domain. We argue that this approach provides a formal framework in which it is convenient to work with different types of graph constructions (or expansions) involved in the proof of the Lov'{a}sz Replication Lemma (LRL)\, which is also the key result used in the proof of Weak Perfect Graph Theorem. Finally\, we use this setting to develop a constructive formalization of the Weak Perfect Graph Theorem.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T173105Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T161820Z
DTEND:20200121T164000Z
DTSTAMP:20191226T230630Z
UID:cd3ffb3c-4ce5-482c-ade4-a89ded0b8a93@conf.researchr.org
CREATED:20191212T193803Z
SUMMARY:[CPP] Completeness of an Axiomatization of Graph Isomorphism via Graph Rewriting in Coq - Christian Doczkal\, Damien Pous
DESCRIPTION:The labeled multigraphs of treewidth at most two can be described using a simple term language over which isomorphism of the denoted graphs can be finitely axiomatized. We formally verify soundness and completeness of such an axiomatization using Coq and the mathematical components library. The completeness proof is based on a normalizing and confluent rewrite system on term-labeled graphs. While for most of the development a dependently typed representation of graphs based on finite types of vertices and edges is most convenient\, we switch to a graph representation employing a fixed type of vertices shared among all graphs for establishing confluence of the rewrite system. The completeness result is then obtained by transferring confluence from the fixed-type setting to the dependently typed setting.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T153500Z
DTEND:20200121T173500Z
DTSTAMP:20191226T230630Z
UID:58181722-ad6e-4749-8124-00f20dfa8095@conf.researchr.org
CREATED:20191116T142516Z
SUMMARY:[POPL mark 15 Year Retrospective Panel] POPLmark 15 Year Retrospective Panel
DESCRIPTION:
LOCATION:POPLmark -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191116T143222Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T153500Z
DTEND:20200121T164000Z
DTSTAMP:20191226T230630Z
UID:e3ca4a0e-04d2-4a95-b8f6-a829b545bf3d@conf.researchr.org
CREATED:20191205T235122Z
SUMMARY:[VMCAI] How to Win First-Order Safety Games - Helmut Seidl\, Christian Müller\, Bernd Finkbeiner
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T164000Z
DTEND:20200121T174500Z
DTSTAMP:20191226T230630Z
UID:9e558a2e-411d-48de-a90b-3ececd27a590@conf.researchr.org
CREATED:20191205T235122Z
SUMMARY:[VMCAI] Improving Parity Game Solvers with Justifications - Ruben Lapauw\, Maurice Bruynooghe\, Marc Denecker
DESCRIPTION:
LOCATION:VMCAI -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191206T000851Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T165000Z
DTEND:20200121T171200Z
DTSTAMP:20191226T230630Z
UID:e6d5dbd4-9efc-4117-a864-9de3e7fc66a4@conf.researchr.org
CREATED:20191212T193920Z
SUMMARY:[CPP] The Poincaré-Bendixson Theorem in Isabelle/HOL - Fabian Immler\, Yong Kiam Tan
DESCRIPTION:The Poincaré-Bendixson theorem is a classical result in the study of (continuous) dynamical systems. Colloquially\, it restricts the possible behaviors of planar dynamical systems: such systems cannot be chaotic. In practice\, it is a useful tool for proving the existence of (limiting) periodic behavior in planar systems. The theorem is an interesting and challenging benchmark for formalized mathematics because proofs in the literature rely on geometric sketches and only hint at symmetric cases. It also requires a substantial background of mathematical theories\, e.g.\, the Jordan curve theorem\, real analysis\, ordinary differential equations\, and limiting (long-term) behavior of dynamical systems. \nWe present a proof of the theorem in Isabelle/HOL and highlight the main challenges\, which include: i) combining large and independently developed mathematical libraries\, namely the Jordan curve theorem and ordinary differential equations\, ii) formalizing fundamental concepts for the study of dynamical systems\, namely the α\, ω-limit sets\, and periodic orbits\, iii) providing formally rigorous arguments for the geometric sketches paramount in the literature\, and iv) managing the complexity of our formalization throughout the proof\, e.g.\, appropriately handling symmetric cases.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191221T014722Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T171200Z
DTEND:20200121T173400Z
DTSTAMP:20191226T230630Z
UID:1682afb7-37cb-46a6-bd6f-487067e26c80@conf.researchr.org
CREATED:20191212T193920Z
SUMMARY:[CPP] A Formal Proof of the Independence of the Continuum Hypothesis - Jesse Michael Han\, Floris van Doorn
DESCRIPTION:We describe a formal proof of the independence of the continuum hypothesis ($\mathsf{CH}$) in the Lean theorem prover. We use Boolean-valued models to give forcing arguments for both directions\, using Cohen forcing for the consistency of $\neg \mathsf{CH}$ and a $\sigma$-closed forcing for the consistency of $\mathsf{CH}$.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191212T201122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200121T173400Z
DTEND:20200121T175600Z
DTSTAMP:20191226T230630Z
UID:0b000c1e-9b22-4c3a-b5ed-fee8b4a4ae1a@conf.researchr.org
CREATED:20191212T193920Z
SUMMARY:[CPP] The Lean mathematical library - The mathlib Community 
DESCRIPTION:This paper describes mathlib\, a community-driven effort to build a unified library of mathematics formalized in the Lean proof assistant. Among proof assistant libraries\, it is distinguished by its dependently typed foundations\, focus on classical mathematics\, extensive hierarchy of structures\, use of large- and small-scale automation\, and distributed organization. We explain the architecture and design decisions of the library and the social organization that has led to its development.
LOCATION:CPP -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191216T214419Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T084500Z
DTEND:20200122T090000Z
DTSTAMP:20191226T230630Z
UID:41231b0f-b0b2-430a-bcaf-6c7ae4756a61@conf.researchr.org
CREATED:20191127T173731Z
SUMMARY:[POPL Research Papers] Welcome + SIGPLAN Award Ceremony
DESCRIPTION:
LOCATION:POPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191127T173731Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T090000Z
DTEND:20200122T100000Z
DTSTAMP:20191226T230630Z
UID:cfb3e161-5a78-4bd6-90f9-f755cae53b0c@conf.researchr.org
CREATED:20191127T174054Z
SUMMARY:[POPL Research Papers] Invited Talk - Martin Vechev - Martin Vechev
DESCRIPTION:
LOCATION:POPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191128T072235Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T103000Z
DTEND:20200122T105140Z
DTSTAMP:20191226T230630Z
UID:60ac46cf-1b69-4cc7-a5d6-d9566693795d@conf.researchr.org
CREATED:20191127T175029Z
SUMMARY:[POPL Research Papers] The Weak Call-By-Value λ-Calculus is Reasonable for Both Time and Space - Yannick Forster\, Fabian Kunze\, Marc Roth
DESCRIPTION:We study the weak call-by-value λ-calculus as a model for computational complexity theory and establish the natural measures for time and space — the number of beta-reduction steps and the size of the largest term in a computation — as reasonable measures with respect to the invariance thesis of Slot and van Emde Boas from 1984. More precisely\, we show that\, using those measures\, Turing machines and the weak call-by-value λ-calculus can simulate each other within a polynomial overhead in time and a constant factor overhead in space for all computations terminating in (encodings of) “true” or “false”. The simulation yields that standard complexity classes like P\, NP\, PSPACE\, or EXP can be defined solely in terms of the λ-calculus\, but does not cover sublinear time or space. \nNote that our measures still have the well-known size explosion property\, where the space measure of a computation can be exponentially bigger than its time measure. However\, our result implies that this exponential gap disappears once complexity classes are considered instead of concrete computations. \nWe consider this result a first step towards a solution for the long-standing open problem of whether the natural measures for time and space of the λ-calculus are reasonable. Our proof for the weak call-by-value λ-calculus is the first proof of reasonability (including both time and space) for a functional language based on natural measures and enables the formal verification of complexity-theoretic proofs concerning complexity classes\, both on paper and in proof assistants. \nThe proof idea relies on a hybrid of two simulation strategies of reductions in the weak call-by-value λ-calculus by Turing machines\, both of which are insufficient if taken alone. The first strategy is the most naive one in the sense that a reduction sequence is simulated precisely as given by the reduction rules\; in particular\, all substitutions are executed immediately. This simulation runs within a constant overhead in space\, but the overhead in time might be exponential. The second strategy is heap-based and relies on structure sharing\, similar to existing compilers of eager functional languages. This strategy only has a polynomial overhead in time\, but the space consumption might require an additional factor of log n\, which is essentially due to the size of the pointers required for this strategy. Our main contribution is the construction and verification of a space-aware interleaving of the two strategies\, which is shown to yield both a constant overhead in space and a polynomial overhead in time.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T105140Z
DTEND:20200122T111320Z
DTSTAMP:20191226T230630Z
UID:f63c537d-e631-4084-b09e-8904a0d77049@conf.researchr.org
CREATED:20191127T175029Z
SUMMARY:[POPL Research Papers] Complexity and Information in Invariant Inference - Yotam Feldman\, Neil Immerman\, Mooly Sagiv\, Sharon Shoham
DESCRIPTION:This paper addresses the complexity of SAT-based invariant inference\, a prominent approach to safety verification. We consider the problem of inferring an inductive invariant of polynomial length given a transition system and a safety property. We analyze the complexity of this problem in a black-box model\, called the Hoare-query model\, which is general enough to capture algorithms such as IC3/PDR and its variants. An algorithm in this model learns about the system’s reachable states by querying the validity of Hoare triples. \nWe show that in general an algorithm in the Hoare-query model requires an exponential number of queries. Our lower bound is information-theoretic and applies even to computationally unrestricted algorithms\, showing that no choice of generalization from the partial information obtained in a polynomial number of Hoare queries can lead to an efficient invariant inference procedure in this class. \nWe then show\, for the first time\, that by utilizing rich Hoare queries\, as done in PDR\, inference can be exponentially more efficient than approaches such as ICE learning\, which only utilize inductiveness checks of candidates. We do so by constructing a class of transition systems for which a simple version of PDR with a single frame infers invariants in a polynomial number of queries\, whereas every algorithm using only inductiveness checks and counterexamples requires an exponential number of queries. \nOur results also shed light on connections and differences with the classical theory of exact concept learning with queries\, and imply that learning from counterexamples to induction is harder than classical exact learning from labeled examples. This demonstrates that the convergence rate of Counterexample-Guided Inductive Synthesis depends on the form of counterexamples.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T111320Z
DTEND:20200122T113500Z
DTSTAMP:20191226T230630Z
UID:e52a1939-2da5-43d4-9dbc-849e5bf8fd59@conf.researchr.org
CREATED:20191127T175029Z
SUMMARY:[POPL Research Papers] Parameterized Verification under TSO is PSPACE-Complete - Parosh Aziz Abdulla\, Mohamed Faouzi Atig\, Rojin Rezvan
DESCRIPTION:We consider parameterized verification of concurrent programs under the Total Store Order (TSO) semantics. A program consists of a set of processes that share a set of variables on which they can perform read and write operations. We show that the reachability problem for a system consisting of an arbitrary number of identical processes is Pspace-complete. We prove that the complexity is reduced to polynomial time if the processes are not allowed to read the initial values of the variables in the memory. When the processes are allowed to perform atomic read-modify-write operations\, the reachability problem has a non-primitive recursive complexity.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T103000Z
DTEND:20200122T105140Z
DTSTAMP:20191226T230630Z
UID:541f0e10-a408-4234-b553-754bba2551ef@conf.researchr.org
CREATED:20191127T175124Z
SUMMARY:[POPL Research Papers] Towards Verified Stochastic Variational Inference for Probabilistic Programs - Wonyeol Lee\, Hangyeol Yu\, Xavier Rival\, Hongseok Yang
DESCRIPTION:Probabilistic programming is the idea of writing models from statistics and machine learning using program notations and reasoning about these models using generic inference engines. Recently its combination with deep learning has been explored intensely\, which led to the development of so called deep probabilistic programming languages\, such as Pyro\, Edward and ProbTorch. At the core of this development lie inference engines based on stochastic variational inference algorithms. When asked to find information about the posterior distribution of a model written in such a language\, these algorithms convert this posterior-inference query into an optimisation problem and solve it approximately by a form of gradient ascent or descent. In this paper\, we analyse one of the most fundamental and versatile variational inference algorithms\, called score estimator or REINFORCE\, using tools from denotational semantics and program analysis. We formally express what this algorithm does on models denoted by programs\, and expose implicit assumptions made by the algorithm on the models. The violation of these assumptions may lead to an undefined optimisation objective or the loss of convergence guarantee of the optimisation process. We then describe rules for proving these assumptions\, which can be automated by static program analyses. Some of our rules use nontrivial facts from continuous mathematics\, and let us replace requirements about integrals in the assumptions\, such as integrability of functions defined in terms of programs’ denotations\, by conditions involving differentiation or boundedness\, which are much easier to prove automatically (and manually). Following our general methodology\, we have developed a static program analysis for the Pyro programming language that aims at discharging the assumption about what we call model-guide support match. Our analysis is applied to the eight representative model-guide pairs from the Pyro webpage\, which include sophisticated neural network models such as AIR. It finds a bug in one of these cases\, reveals a non-standard use of an inference engine in another\, and shows that the assumptions are met in the remaining six cases.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T105140Z
DTEND:20200122T111320Z
DTSTAMP:20191226T230630Z
UID:edc95e10-7691-4fc5-a1b4-3c7c97ca7448@conf.researchr.org
CREATED:20191127T175124Z
SUMMARY:[POPL Research Papers] Trace Types and Denotational Semantics for Sound Programmable Inference in Probabilistic Languages - Alexander K. Lew\, Marco Cusumano-Towner\, Benjamin Sherman\, Michael Carbin\, Vikash Mansinghka
DESCRIPTION:Modern probabilistic programming languages aim to formalize and automate key aspects of probabilistic modeling and inference. Many languages provide constructs for programmable inference that enable developers to improve inference speed and accuracy. Unfortunately\, it is easy to use these constructs to write unsound programs that appear to run correctly but that produce meaningless results. This paper presents a denotational semantics for higher-order probabilistic programs with programmable inference\, along with a type system that ensures that well-typed inference programs are sound by construction. A central insight is that the type of a probabilistic expression can track the space of its possible execution traces\, not just the type of value that it returns\, as these traces are often the objects that are manipulated during inference. We use our semantics and type system to establish soundness properties of custom inference programs that use constructs for variational\, sequential Monte Carlo\, importance sampling\, and Markov chain Monte Carlo inference.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T111320Z
DTEND:20200122T113500Z
DTSTAMP:20191226T230630Z
UID:1ae94288-27a6-4be3-abfa-20265d9ffbd2@conf.researchr.org
CREATED:20191127T175124Z
SUMMARY:[POPL Research Papers] Semantics of Higher-Order Probabilistic Programs with Conditioning - Fredrik Dahlqvist\, Dexter Kozen
DESCRIPTION:We present a denotational semantics for higher-order probabilistic programs in terms of linear operators between Banach spaces. Our semantics is rooted in the classical theory of Banach spaces and their tensor products\, but bears similarities with the well-known semantics of higher-order programs a la Scott through the use of ordered Banach spaces which allow definitions in terms of fixed points. Our semantics is a model of intuitionistic linear logic: it is linear because it is based on a symmetric monoidal closed category of ordered Banach spaces\, but by constructing an exponential comonad we can also accommodate non-linear reasoning. We apply our semantics to the verification of the classical Gibbs sampling algorithm.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T114500Z
DTEND:20200122T120730Z
DTSTAMP:20191226T230630Z
UID:36389155-747e-46dd-a3c0-02784365e72c@conf.researchr.org
CREATED:20191127T175334Z
SUMMARY:[POPL Research Papers] Recurrence Extraction for Functional Programs through Call-by-Push-Value - G. A. Kavvos\, Edward Morehouse\, Dan Licata\, Norman Danner
DESCRIPTION:The main way of analyzing the complexity of a program is that of extracting and solving a recurrence that expresses its running time in terms of the size of its input. We develop a method that automatically extracts such recurrences from the syntax of higher-order recursive functional programs. The resulting recurrences\, which are programs in a call-by-name language with recursion\, explicitly compute the running time in terms of the size of the input. In order to achieve this in a uniform way that covers both call-by-name and call-by-value evaluation strategies\, we use Call-by-Push-Value (CBPV) as an intermediate language. Finally\, we use domain theory to develop a denotational cost semantics for the resulting recurrences.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T120730Z
DTEND:20200122T123000Z
DTSTAMP:20191226T230630Z
UID:f2a2ebad-a34c-44c0-8574-3690251a8658@conf.researchr.org
CREATED:20191127T175334Z
SUMMARY:[POPL Research Papers] Liquidate Your Assets: Reasoning About Resource Usage in Liquid Haskell - Martin Adam Thomas Handley\, Niki Vazou\, Graham Hutton
DESCRIPTION:Liquid Haskell is an extension to the type system of Haskell that supports formal reasoning about program correctness by encoding logical properties as refinement types. In this article\, we show how Liquid Haskell can also be used to reason about program efficiency in the same setting\, with the system’s existing verification machinery being used to ensure that the results are both valid and precise. To illustrate our approach\, we analyse the efficiency of a wide range of popular data structures and algorithms\, and in doing so\, explore various notions of resource usage. Our experience is that reasoning about efficiency in Liquid Haskell is often just as simple as reasoning about correctness\, and that the two can naturally be combined.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T114500Z
DTEND:20200122T120730Z
DTSTAMP:20191226T230630Z
UID:aec83aa6-44cb-4119-bb66-0f436f7fd795@conf.researchr.org
CREATED:20191127T175414Z
SUMMARY:[POPL Research Papers] Program Synthesis by Type-Guided Abstraction Refinement - Zheng Guo\, Michael James\, David Justo\, Jiaxiao Zhou\, Ziteng Wang\, Ranjit Jhala\, Nadia Polikarpova
DESCRIPTION:We consider the problem of type-directed component-based synthesis where\, given a set of (typed) components and a query type\, the goal is to synthesize a term that inhabits the query. Classical approaches based on proof search in intuitionistic logics do not scale up to the standard libraries of modern languages\, which span hundreds or thousands of components. Recent graph reachability based methods proposed for Java do scale\, but only apply to monomorphic data and components: polymorphic data and components infinitely explode the size of the graph that must be searched\, rendering synthesis intractable. We introduce type-guided abstraction refinement (TYGAR)\, a new approach for scalable type-directed synthesis over polymorphic datatypes and components. Our key insight is that we can overcome the explosion by building a graph over abstract types which represent a potentially unbounded set of concrete types. We show how to use graph reachability to search for candidate terms over abstract types\, and introduce a new algorithm that uses proofs of untypeability of ill-typed candidates to iteratively refine the abstraction until a well-typed result is found. \nWe have implemented TYGAR in H+\, a tool that takes as input a set of Haskell libraries and a query type\, and returns a Haskell term that uses functions from the provided libraries to implement the query type. Our support for polymorphism allows H+ to work with higher-order functions and type classes\, and enables more precise queries due to parametricity. We have evaluated H+ on 44 queries using a set of popular Haskell libraries with a total of 291 components. H+ returns an interesting solution within the first five results for 32 out of 44 queries. Our results show that TYGAR allows H+ to rapidly return well-typed terms\, with the median time to first solution of just 1.4 seconds. Moreover\, we observe that gains from iterative refinement over exhaustive enumeration are more pronounced on harder queries.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T120730Z
DTEND:20200122T123000Z
DTSTAMP:20191226T230630Z
UID:de347690-546f-4bc8-a290-a6d32ab301dc@conf.researchr.org
CREATED:20191127T175414Z
SUMMARY:[POPL Research Papers] Synthesizing Replacement Classes - Malavika Samak\, Deokhwan Kim\, Martin Rinard
DESCRIPTION:We present a new technique for automatically synthesizing replacement classes. The technique starts with an original class O and a potential replacement class R\, then uses R to synthesize a new class that implements the same interface and provides the same functionality as O. Critically\, our technique works with a synthesized inter-class equivalence predicate between the states of O and R. It uses this predicate to ensure that original and synthesized methods leave corresponding O and R objects in equivalent states. The predicate therefore enables the technique to synthesize individual replacement methods in isolation while still obtaining a replacement class that leaves the original and replacement objects in equivalent states after arbitrarily long method invocation sequences. We have implemented the technique and evaluated it using popular Java classes from open-source libraries such as JDK and apache. The results from this implementation highlight the effectiveness of the technique in synthesizing replacement classes.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T123000Z
DTEND:20200122T140000Z
DTSTAMP:20191226T230630Z
UID:f090eef3-ee2d-4cc4-aa8a-99e9cc2e05b1@conf.researchr.org
CREATED:20191128T063939Z
SUMMARY:[POPL Catering] Lunch
DESCRIPTION:Lunch
LOCATION:Lunch Room -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191128T065511Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T140000Z
DTEND:20200122T142140Z
DTSTAMP:20191226T230630Z
UID:036ff8bf-6aa9-470b-bc6e-0f5df89a9ad2@conf.researchr.org
CREATED:20191127T175623Z
SUMMARY:[POPL Research Papers] What is Decidable about Gradual Types? - Zeina Migeed\, Jens Palsberg
DESCRIPTION:Programmers can use gradual types to migrate programs to have more precise type annotations and thereby improve their readability\, efficiency\, and safety. Such migration requires an exploration of the migration space and can benefit from tool support\, as shown in previous work. Our goal is to provide a foundation for better tool support by settling decidability questions about migration with gradual types. We present three algorithms and a hardness result for deciding key properties and we explain how they can be useful during an exploration. In particular\, we show how to decide whether the migration space is finite\, whether it has a top element\, and whether it is a singleton. We also show that deciding whether it has a maximal element is NP-hard. Our implementation of our algorithms worked as expected on a suite of microbenchmarks.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T142140Z
DTEND:20200122T144320Z
DTSTAMP:20191226T230630Z
UID:bb1b3273-1af9-46fe-a3cb-66a1ccb06952@conf.researchr.org
CREATED:20191127T175623Z
SUMMARY:[POPL Research Papers] Graduality and Parametricity: Together Again for the First Time - Max New\, Dustin Jamner\, Amal Ahmed
DESCRIPTION:Parametric polymorphism and gradual typing have proven to be a difficult combination\, with no language yet produced that satisfies the fundamental theorems of each: parametricity and graduality. Notably\, Toro\, Labrada\, and Tanter (POPL 2019) conjecture that for any gradual extension of System F that uses dynamic type generation\, graduality and parametricity are “simply incompatible”. However\, we argue that it is not graduality and parametricity that are incompatible per se\, but instead that combining the syntax of System F with dynamic type generation as in previous work necessitates type-directed computation\, which we show has been a common source of graduality and parametricity violations in previous work. \nWe then show that by modifying the syntax of universal and existential types to make the type name generation explicit\, we remove the need for type-directed computation\, and get a language that satisfies both graduality and parametricity theorems. The language has a simple runtime semantics\, which can be explained by translation to a statically typed language where the dynamic type is interpreted as a dynamically extensible sum type. Far from being in conflict\, we show that the parametricity theorem follows as a direct corollary of a relational interpretation of the graduality property.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T144320Z
DTEND:20200122T150500Z
DTSTAMP:20191226T230630Z
UID:4f0e543f-6fa6-44b6-b026-e4488c0b9d50@conf.researchr.org
CREATED:20191127T175623Z
SUMMARY:[POPL Research Papers] Does Blame Shifting Work? - Lukas Lazarek\, Alexis King\, Samanvitha Sundar\, Robby Findler\, Christos Dimoulas
DESCRIPTION:Contract systems\, especially of the higher-order flavor\, go hand in hand with blame. The pragmatic purpose of blame is to narrow down the code that a programmer needs to examine to locate the bug when the contract system discovers a contract violation. Or so the literature on higher-order contracts claims. \nIn reality\, however\, there is neither empirical nor theoretical evidence that connects blame with the location of bugs. The reputation of blame as a tool for weeding out bugs rests on anecdotes about how programmers use contracts to shift blame and their attention from one part of a program to another until they discover the source of the problem. \nThis paper aims to fill the apparent gap and shed light to the relation between blame and bugs. To that end\, we introduce an empirical methodology for investigating whether\, for a contract system\, it is possible to translate blame information to the location of bugs in a systematic manner. Our methodology is inspired by how programmers attempt to increase the precision of the contracts of a blamed component in order to shift blame to another component\, which becomes the next candidate for containing the bug. In particular\, we construct a framework that enables us to ask for a contract system whether (i) the process of blame shifting leads blame to settle eventually to the component that contains the bug\; and (ii) every shift moves blame “closer” to the faulty component. \nHence our methodology offers a rigorous means for evaluating the pragmatics of contract systems\, and we employ it to analyze Racket’s contract system. Along the way\, we uncover subtle points about the pragmatic meaning of contracts and blame in Racket: (i) the expressiveness of Racket’s off-the-shelf contract language is not sufficient to narrow down the blamed portion of the code to the faulty component in all cases\; and (ii) Racket contracts interfere with program evaluation in subtle ways and thus blame shifting can lead programmers on a detour when searching for a bug.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T140000Z
DTEND:20200122T142140Z
DTSTAMP:20191226T230630Z
UID:c8f42a96-e55d-4791-a0a2-f256b08ac8c1@conf.researchr.org
CREATED:20191127T174936Z
SUMMARY:[POPL Research Papers] The Future is Ours: Prophecy Variables in Separation Logic - Ralf Jung\, Rodolphe Lepigre\, Gaurav Parthasarathy\, Marianna Rapoport\, Amin Timany\, Derek Dreyer\, Bart Jacobs
DESCRIPTION:Early in the development of Hoare logic\, Owicki and Gries introduced auxiliary variables as a way of encoding information about the history of a program’s execution that is useful for verifying its correctness. Over a decade later\, Abadi and Lamport observed that it is sometimes also necessary to know in advance what a program will do in the future. To address this need\, they proposed prophecy variables\, originally as a proof technique for refinement mappings between state machines. However\, despite the fact that prophecy variables are a clearly useful reasoning mechanism\, there is (surprisingly) almost no work that attempts to integrate them into Hoare logic. In this paper\, we present the first account of prophecy variables in a Hoare-style program logic that is flexible enough to verify logical atomicity (a relative of linearizability) for classic examples from the concurrency literature like RDCSS and the Herlihy-Wing queue. Our account is formalized in the Iris framework for separation logic in Coq. It makes essential use of ownership to encode the exclusive right to resolve a prophecy\, which in turn enables us to enforce soundness of prophecies with a very simple set of proof rules.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T142140Z
DTEND:20200122T144320Z
DTSTAMP:20191226T230630Z
UID:255fcd38-8458-4c2e-8322-692a3e00b63a@conf.researchr.org
CREATED:20191127T174936Z
SUMMARY:[POPL Research Papers] Spy Game: Verifying a Local Generic Solver in Iris - Paulo Emílio de Vilhena\, François Pottier\, Jacques-Henri Jourdan
DESCRIPTION:We verify the partial correctness of a “local generic solver”\, that is\, an on-demand\, incremental\, memoizing least fixed point computation algorithm. The verification is carried out in Iris\, a modern breed of concurrent separation logic. The specification is simple: the solver computes the optimal least fixed point of a system of monotone equations. Although the solver relies on mutable internal state for memoization and for “spying”\, a form of dynamic dependency discovery\, it is apparently pure: no side effects are mentioned in its specification. As auxiliary contributions\, we provide several illustrations of the use of prophecy variables\, a novel feature of Iris\; we establish a restricted form of the infinitary conjunction rule\; and we provide a specification and proof of Longley’s modulus function\, an archetypical example of spying.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T144320Z
DTEND:20200122T150500Z
DTSTAMP:20191226T230630Z
UID:30675fbe-b11a-46c8-a0de-6610c8d766d7@conf.researchr.org
CREATED:20191127T174936Z
SUMMARY:[POPL Research Papers] Actris: Session-Type Based Reasoning in Separation Logic - Jonas Kastberg Hinrichsen\, Jesper Bengtson\, Robbert Krebbers
DESCRIPTION:Message passing is a useful abstraction to implement concurrent programs. For real-world systems\, however\, it is often combined with other programming and concurrency paradigms\, such as higher-order functions\, mutable state\, shared-memory concurrency\, and locks. We present Actris: a logic for proving functional correctness of programs that use a combination of the aforementioned features. Actris combines the power of modern concurrent separation logics with a first-class protocol mechanism—based on session types—for reasoning about message passing in the presence of other concurrency paradigms. We show that Actris provides a suitable level of abstraction by proving functional correctness of a variety of examples\, including a distributed merge sort\, a distributed load-balancing mapper\, and a variant of the map-reduce model\, using relatively simple specifications. Soundness of Actris is proved using a model of its protocol mechanism in the Iris framework. We mechanised the theory of Actris\, together with tactics for symbolic execution of programs\, as well as all examples in the paper\, in the Coq proof assistant.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T035334Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T153500Z
DTEND:20200122T155640Z
DTSTAMP:20191226T230630Z
UID:b00cd114-7388-4e8c-98d2-286846f38151@conf.researchr.org
CREATED:20191127T175841Z
SUMMARY:[POPL Research Papers] A Simple Differentiable Programming Language - Gordon Plotkin\, Martín Abadi
DESCRIPTION:Automatic differentiation plays a prominent role in scientific computing and in modern machine learning\, often in the context of powerful programming systems. The relation of the various embodiments of automatic differentiation to the mathematical notion of derivative is not always entirely clear—discrepancies can arise\, sometimes inadvertently. In order to study automatic differentiation in such programming contexts\, we define a small but expressive programming language that includes a construct for reverse-mode differentiation. We give operational and denotational semantics for this language. The operational semantics employs popular implementation techniques\, while the denotational semantics employs notions of differentiation familiar from real analysis. We establish that these semantics coincide.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T035253Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T155640Z
DTEND:20200122T161820Z
DTSTAMP:20191226T230630Z
UID:2e74f4d0-a500-417f-bf03-32ac2e8c53c2@conf.researchr.org
CREATED:20191127T175841Z
SUMMARY:[POPL Research Papers] Backpropagation in the Simply Typed Lambda-calculus with Linear Negation - Aloïs Brunel\, Damiano Mazza\, Michele Pagani
DESCRIPTION:Backpropagation is a classic automatic differentiation algorithm computing the gradient of functions specified by a certain class of simple\, first-order programs\, called computational graphs. It is a fundamental tool in several fields\, most notably machine learning\, where it is the key for efficiently training (deep) neural networks. Recent years have witnessed the quick growth of a research field called differentiable programming\, the aim of which is to express computational graphs more synthetically and modularly by resorting to actual programming languages endowed with control flow operators and higher-order combinators\, such as map and fold. In this paper\, we extend the backpropagation algorithm to a paradigmatic example of such a programming language: we define a compositional program transformation from the simply-typed lambda-calculus to itself augmented with a notion of linear negation\, and prove that this computes the gradient of the source program with the same efficiency as first-order backpropagation. The transformation is completely effect-free and thus provides a purely logical understanding of the dynamics of backpropagation.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T161820Z
DTEND:20200122T164000Z
DTSTAMP:20191226T230630Z
UID:648bb295-6a17-40d9-b5d4-e51d09ff70d0@conf.researchr.org
CREATED:20191127T175841Z
SUMMARY:[POPL Research Papers] Guarded Kleene Algebra with Tests: Verification of Uninterpreted Programs in Nearly Linear Time - Steffen Smolka\, Nate Foster\, Justin Hsu\, Tobias Kappé\, Dexter Kozen\, Alexandra Silva
DESCRIPTION:Guarded Kleene Algebra with Tests (GKAT) is a variation on Kleene Algebra with Tests (KAT) that arises by restricting the union (+) and iteration (∗) operations from KAT to predicate-guarded versions. We develop the (co)algebraic theory of GKAT and show how it can be efficiently used to reason about imperative programs. In contrast to KAT\, whose equational theory is PSPACE-complete\, we show that the equational theory of GKAT is (almost) linear time. We also provide a full Kleene theorem and prove completeness for an analogue of Salomaa’s axiomatization of Kleene Algebra.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T153500Z
DTEND:20200122T155640Z
DTSTAMP:20191226T230630Z
UID:794bbc10-4814-4f0e-b1a7-d35c0a4e2aba@conf.researchr.org
CREATED:20191127T180027Z
SUMMARY:[POPL Research Papers] Persistency Semantics of the Intel-x86 Architecture - Azalea Raad\, John Wickerson\, Gil Neiger\, Viktor Vafeiadis
DESCRIPTION:Emerging non-volatile memory (NVM) technologies promise the durability of disks with the performance of volatile memory (RAM). To describe the persistency guarantees of NVM\, several memory persistency models have been proposed. However\, the persistency semantics of the ubiquitous x86 architecture remains unexplored to date. To close this gap\, we develop the Px86 (‘persistent x86’) model\, formalising the persistency semantics of x86 for the first time. We formulate Px86 both operationally and declaratively\, and prove that the two characterisations are equivalent. To demonstrate the application of Px86 and to make persistent programming accessible to the uninitiated programmer\, we develop two persistent libraries over Px86: a persistent transactional library\, and a persistent variant of the Michael-Scott queue library. We further showcase the application of Px86 by encoding it in Alloy and generating persistency litmus tests automatically.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T155640Z
DTEND:20200122T161820Z
DTSTAMP:20191226T230630Z
UID:c30872c1-16ee-4cc5-9431-f362521b096c@conf.researchr.org
CREATED:20191127T180027Z
SUMMARY:[POPL Research Papers] Reductions for Safety Proofs - Azadeh Farzan\, Anthony Vandikas
DESCRIPTION:Program reductions are used widely to simplify reasoning about the correctness of concurrent and distributed programs. Different reduction techniques are often tailored towards specific classes of programs\, for example message passing vs shared memory. In this paper\, we propose a general approach to proof simplification of concurrent programs based on exploring generic classes of reductions. We introduce two classes of sound program reductions\, study their theoretical properties\, show how they can be effectively used in algorithmic verification\, and demonstrate that they are very effective in producing proofs of a diverse class of programs without targeting specific syntactic properties of these programs. We modify the classic counterexample-guided refinement loop of automated program verification so that\, in addition to proof search\, it also searches for a program reduction that admits a substantially simpler proof of correctness compared to the original program. This methodology\, hence\, succeeds in automatically generating proofs for programs whose full proofs are theoretically outside the reach of current automated verification technology.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T161820Z
DTEND:20200122T164000Z
DTSTAMP:20191226T230630Z
UID:e6eb6bf0-06cc-4c92-8604-79df9139e011@conf.researchr.org
CREATED:20191127T180027Z
SUMMARY:[POPL Research Papers] RustBelt Meets Relaxed Memory - Hoang-Hai Dang\, Jacques-Henri Jourdan\, Jan-Oliver Kaiser\, Derek Dreyer
DESCRIPTION:The Rust programming language supports safe systems programming by means of a strong ownership-tracking type system. In their prior work on RustBelt\, Jung et al. began the task of setting Rust’s safety claims on a more rigorous formal foundation. Specifically\, they used Iris\, a Coq-based separation logic framework\, to build a machine-checked proof of semantic soundness for a λ-calculus model of Rust\, as well as for a number of widely-used Rust libraries that internally employ unsafe language features. However\, they also made the significant simplifying assumption that the language is sequentially consistent. In this paper\, we adapt RustBelt to account for the relaxed-memory operations that concurrent Rust libraries actually use\, in the process uncovering a data race in the Arc library. We focus on the most interesting technical problem: how to reason about resource reclamation under relaxed memory\, using a logical construction we call synchronized ghost state.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T165000Z
DTEND:20200122T190000Z
DTSTAMP:20191226T230630Z
UID:f1d26eb5-c04b-4d2e-ab7c-9812f509793c@conf.researchr.org
CREATED:20191218T015337Z
SUMMARY:[POPL Student Research Competition] SRC Poster Session
DESCRIPTION:
LOCATION:SRC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191218T015337Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T165000Z
DTEND:20200122T171230Z
DTSTAMP:20191226T230630Z
UID:e8010267-2c02-4b59-9f2d-ace12171e385@conf.researchr.org
CREATED:20191127T180237Z
SUMMARY:[POPL Research Papers] Visualization by Example - Chenglong Wang\, Yu Feng\, Rastislav Bodik\, Alvin Cheung\, Isil Dillig
DESCRIPTION:While visualizations play a crucial role in gaining insights from data\, generating useful visualizations from a complex dataset is far from an easy task. In particular\, besides understanding the functionality provided by existing visualization libraries\, generating the desired visualization also requires reshaping and aggregating the underlying data as well as composing different visual elements to achieve the intended visual narrative. This paper aims to simplify visualization tasks by automatically synthesizing the required program from simple visual sketches provided by the user. Specifically\, given an input data set and a visual sketch that demonstrates how to visualize a very small subset of this data\, our technique automatically generates a program that can be used to visualize the entire data set. \nFrom a program synthesis perspective\, automating visualization tasks poses several challenges that are not addressed by prior techniques. First\, because many visualization tasks require data wrangling in addition to generating plots from a given table\, we need to decompose the end-to-end synthesis task into two separate sub-problems. Second\, because the intermediate specification that results from the decomposition is necessarily imprecise\, this makes the data wrangling task particularly challenging in our context. In this paper\, we address these problems by developing a new compositional visualization-by-example technique that (a) decomposes the end-to-end task into two different synthesis problems over different DSLs and (b) leverages bi-directional program analysis to deal with the complexity that arises from having an imprecise intermediate specification. \nWe have implemented our visualization-by-example approach in a tool called Viser and evaluate it on over 80 visualization tasks collected from on-line forums and tutorials. Viser can solve 84 of these benchmarks within a 600 second time limit\, and\, for those tasks that can be solved\, the desired visualization is among the top-5 generated by Viser in 70% of the cases.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200122T171230Z
DTEND:20200122T173500Z
DTSTAMP:20191226T230630Z
UID:45bdb842-0851-4a6e-80bc-119ea0d1e2f0@conf.researchr.org
CREATED:20191127T180237Z
SUMMARY:[POPL Research Papers] Deciding Memory Safety for Single-Pass Heap-Manipulating Programs - Umang Mathur\, Adithya Murali\, Paul Krogmeier\, P. Madhusudan\, Mahesh Viswanathan
DESCRIPTION:We investigate the decidability of completely automatic program verification for programs that manipulate heaps\, and in particular decision procedures for proving memory safety. The work in [Mathur et al. 2019a] identifies decidable sub-classes of uninterpreted programs\, but does not address programs that can update functions\, which are crucial to model heap-manipulating programs. We develop a new theory of programs\, called alias-aware coherent programs\, that admits decidable verification. We apply this theory to develop verification algorithms for memory safety— determining if a heap-manipulating program that allocates/frees memory locations and manipulates heap pointers does not dereference a memory location that is not allocated. \nWe consider this problem when the initial allocated heap forms a forest data-structure (i.e.\, a disjoint set of trees and lists). While the problem of checking memory safety of programs whose initial heap is a forest data-structure is undecidable\, we identify a class of streaming-coherent programs for which the problem is decidable. Our experimental evaluation demonstrates that common library routines that manipulate forest data-structures using a single pass almost always fall in our decidable class. And show that our decision procedure for these programs is effective in both proving memory safety and in identifying memory safety errors.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T090000Z
DTEND:20200123T100000Z
DTSTAMP:20191226T230630Z
UID:aa4b8810-b89d-43f8-bc44-5671600ead95@conf.researchr.org
CREATED:20191127T180343Z
SUMMARY:[POPL Research Papers] What is a Secure Programming Language?  - Cristina Cifuentes
DESCRIPTION:Our most sensitive and important software systems are written in programming languages that are inherently insecure\, making the security of the systems themselves extremely challenging. It is often said that these systems were written with the best tools available at the time\, so over time with newer languages will come more security. But we contend that all of today’s mainstream programming languages are insecure\, including even the most recent ones that come with claims that they are designed to be “secure”. Our real criticism is the lack of a common understanding of what “secure” might mean in the context of programming language design. We propose a simple data-driven definition for a secure programming language: that it provides first-class language support to address the causes for the most common\, significant vulnerabilities found in real-world software. To discover what these vulnerabilities actually are\, we have analysed the National Vulnerability Database and devised a novel categorisation of the software defects reported in the database. This leads us to propose three broad categories\, which account for over 50% of all reported software vulnerabilities\, that\, as a minimum\, any secure language should address. While most mainstream languages address at least one of these categories\, interestingly\, we find that none address all three. \nLooking at today’s real-world software systems\, we observe a paradigm shift in design and implementation towards service-oriented architectures\, such as microservices. Such systems consist of many fine-grained processes\, typically implemented in multiple languages\, that communicate over the network using simple web-based protocols\, often relying on multiple software environments such as databases. In traditional software systems\, these features are the most common locations for security vulnerabilities\, and so are often kept internal to the system. In microservice systems\, these features are no longer internal but external\, and now represent the attack surface of the software system as a whole. The need for secure programming languages is probably greater now than it has ever been.
LOCATION:POPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191222T140913Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T103000Z
DTEND:20200123T105140Z
DTSTAMP:20191226T230630Z
UID:10acd902-f6f7-40dc-8cf4-5584a0b433dc@conf.researchr.org
CREATED:20191127T180809Z
SUMMARY:[POPL Research Papers] Synthesis of Coordination Programs from Linear Temporal Specifications - Suguman Bansal\, Kedar Namjoshi\, Yaniv Sa'ar
DESCRIPTION:This paper focuses on coordination problems\, and presents a method for synthesizing a reactive program which coordinates the actions of a group of other programs\, so that the combined system satisfies a temporal specification of its desired long-term behavior. Traditionally\, reactive synthesis has been applied to the construction of stateful hardware circuits. This work is motivated by applications to other domains\, such as the control of a network of sensors and devices\, and the management of a heterogeneous team of robots. These applications require coordination between the individual sensors\, devices\, or robots. The mathematical model represents such entities in Hoare’s CSP model\, as a network of interacting processes called the environment. Given a temporal specification\, the synthesis method constructs a coordinator process (if one exists) that guides the actions of the environment processes so that the combined system is deadlock-free and satisfies the given specification. The main technical challenge is that the coordinator may have only partial knowledge of the environment state\, due to non-determinism at the environment interface\, and internal environment actions that are hidden from a coordinator. This is the first method to handle both sources of partial knowledge for arbitrary linear temporal logic specifications. It is also shown that this synthesis problem is PSPACE-hard in the size of the environment. A prototype implementation is able to synthesize compact solutions for a number of coordination specifications.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T105140Z
DTEND:20200123T111320Z
DTSTAMP:20191226T230630Z
UID:a5af0f07-58bf-48a5-b609-024b891559f1@conf.researchr.org
CREATED:20191127T180809Z
SUMMARY:[POPL Research Papers] Augmented Example-based Synthesis using Relational Perturbation Properties - Shengwei An\, Rishabh Singh\, Sasa Misailovic\, Roopsha Samanta
DESCRIPTION:Example-based specifications for program synthesis are inherently ambiguous and may cause synthesizers to generate programs that do not exhibit intended behavior on unseen inputs. Existing synthesis techniques attempt to address this problem by either placing a domain specific\, syntactic bias on the hypothesis space or heavily relying on user feedback to help resolve ambiguity. \nWe present a new framework to address the ambiguity/generalizability problem in example-based synthesis. The key feature of our framework is that it places a semantic bias on the hypothesis space using “relational perturbation properties” that relate the perturbation/change in a program output to the perturbation/change in a program input. An example of such a property is permutation invariance: the program output does not change when the elements of the program input (array) are permuted. The framework is portable across multiple domains and synthesizers and is based on two core steps: (1) automatically augment the set of user-provided examples by “applying” relational perturbation properties and (2) use a generic example-based synthesizer to generate a program consistent with the augmented set of examples. Our framework can be instantiated with three different user interfaces\, with varying degrees of user engagement to help infer relevant relational perturbation properties. This includes an interface in which the user only provides examples and our framework automatically infers relevant properties. We implement our framework in a tool SketchAX specialized to the Sketch synthesizer and demonstrate that SketchAX is effective in significantly boosting the performance of Sketch for all three user interfaces.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T111320Z
DTEND:20200123T113500Z
DTSTAMP:20191226T230630Z
UID:2f333789-a497-4f0b-9aea-3207b019ffdc@conf.researchr.org
CREATED:20191127T180809Z
SUMMARY:[POPL Research Papers] Provenance-Guided Synthesis of Datalog Programs - Mukund Raghothaman\, Jonathan Mendelson\, David Zhao\, Mayur Naik\, Bernhard Scholz
DESCRIPTION:We propose a new approach to synthesize Datalog programs from input-output specifications. Our approach leverages query provenance to scale the counterexample-guided inductive synthesis (CEGIS) procedure for program synthesis. In each iteration of the procedure\, a SAT solver proposes a candidate Datalog program\, and a Datalog solver evaluates the proposed program to determine whether it meets the desired specification. Failure to satisfy the specification results in additional constraints to the SAT solver. We propose efficient algorithms to learn these constraints based on “why” and “why not” provenance information obtained from the Datalog solver. We have implemented our approach in a tool called ProSynth and present experimental results that demonstrate significant improvements over the state-of-the-art\, including in synthesizing invented predicates\, reducing running times\, and in decreasing variances in synthesis performance. On a suite of 40 synthesis tasks from three different domains\, ProSynth is able to synthesize the desired program in 10 seconds on average per task—an order of magnitude faster than baseline approaches—and takes only under a second each for 28 of them.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T103000Z
DTEND:20200123T105140Z
DTSTAMP:20191226T230630Z
UID:5bca69a3-3c64-43a4-82bf-bc068811fa4d@conf.researchr.org
CREATED:20191127T180551Z
SUMMARY:[POPL Research Papers] Binders by Day\, Labels by Night: Effect Instances via Lexically Scoped Handlers - Dariusz Biernacki\, Maciej Piróg\, Piotr Polesiuk\, Filip Sieczkowski
DESCRIPTION:Handlers of algebraic effects aspire to be a practical and robust programming construct that allows one to define\, use\, and combine different computational effects. Interestingly\, a critical problem that still bars the way to their popular adoption is how to combine different uses of the same effect in a program\, particularly in a language with a static type-and-effect system. For example\, it is rudimentary to define the “mutable memory cell” effect as a pair of operations\, put and get\, together with a handler\, but it is far from obvious how to use this effect a number of times to operate a number of memory cells in a single context. In this paper\, we propose a solution based on lexically scoped effects in which each use (an “instance”) of an effect can be singled out by name\, bound by an enclosing handler and tracked in the type of the expression. Such a setting proves to be delicate with respect to the choice of semantics\, as it depends on the explosive mixture of effects\, polymorphism\, and reduction under binders. Hence\, we devise a novel approach to Kripke-style logical relations that can deal with open terms\, which allows us to prove the desired properties of our calculus. We formalise our core results in Coq\, and introduce an experimental surface-level programming language to show that our approach is applicable in practice.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T105140Z
DTEND:20200123T111320Z
DTSTAMP:20191226T230630Z
UID:6e58172c-34e3-4cde-bc5c-f4b7aedea8f8@conf.researchr.org
CREATED:20191127T180551Z
SUMMARY:[POPL Research Papers] The Fire Triangle: How to Mix Substitution\, Dependent Elimination\, and Effects - Pierre-Marie Pédrot\, Nicolas Tabareau
DESCRIPTION:There is a critical tension between substitution\, dependent elimination and effects in type theory. In this paper\, we crystallize this tension in the form of a no-go theorem that constitutes the fire triangle of type theory. \nTo release this tension\, we propose ∂CBPV\, an extension of call-by-push-value (CBPV) —a general calculus of effects—to dependent types. \nThen\, by extending to ∂CBPV the well-known decompositions of call-by-name and call-by-value into CBPV\, we show why\, in presence of effects\, dependent elimination must be restricted in call-by-name\, and substitution must be restricted in call-by-value. \nTo justify ∂CBPV and show that it is general enough to interpret many kinds of effects\, we define various effectful syntactic translations from ∂CBPV to Martin-Löf type theory: the reader\, weaning and forcing translations.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T111320Z
DTEND:20200123T113500Z
DTSTAMP:20191226T230630Z
UID:06506c70-584a-452e-9b61-7b0ea28e7659@conf.researchr.org
CREATED:20191127T180551Z
SUMMARY:[POPL Research Papers] SyTeCi: Automating Contextual Equivalence for Higher-Order Programs with References - Guilhem Jaber
DESCRIPTION:We propose a framework to study contextual equivalence of programs written in a call-by-value functional language with local integer references. It reduces the problem of contextual equivalence to the problem of non-reachability in a transition system of memory configurations. This reduction is complete for recursion-free programs. \nRestricting to programs that do not allocate references inside the body of functions\, we encode this non-reachability problem as a constrained Horn clause that can then be checked for satisfiability automatically. Restricting furthermore to a language with finite data-types\, we also get a new decidability result for contextual equivalence at any type.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T114500Z
DTEND:20200123T120730Z
DTSTAMP:20191226T230630Z
UID:eec7544b-3be7-4356-b12d-52ba4ff31c03@conf.researchr.org
CREATED:20191127T181125Z
SUMMARY:[POPL Research Papers] Seminaïve Evaluation for a Higher-Order Functional Language - Neel Krishnaswami\, Michael Arntzenius
DESCRIPTION:One of the workhorse techniques for implementing bottom-up Datalog engines is seminaive evaluation. This optimization improves the performance of Datalog’s most distinctive feature: recursively defined predicates. Under a naive evaluation strategy\, many values are unnecessarily re-computed\; seminaive evaluation computes (a safe approximation of) just the new values generated at each step. This optimization is critical\, as it can asymptotically improve the performance of Datalog queries. \nSeminaive evaluation is defined partly as a program transformation on sets of Datalog rules\, and partly as a modification of the fixed point computation algorithm\, and takes heavy advantage of the fact that Datalog is fundamentally a first-order programming language. This paper gives an extended version of this transformation which works on higher-order programs written in the Datafun language\, which extends Datalog with features like first-class relations\, higher-order functions\, and datatypes like sum types.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T120730Z
DTEND:20200123T123000Z
DTSTAMP:20191226T230630Z
UID:45bd65a6-1ea2-452e-af47-fc6d478731cd@conf.researchr.org
CREATED:20191127T181125Z
SUMMARY:[POPL Research Papers] Decomposition Diversity with Symmetric Data and Codata - David Binder\, Julian Jabs\, Ingo Skupin\, Klaus Ostermann
DESCRIPTION:The expression problem describes a fundamental trade-off in program design: Should a program’s primary decomposition be determined by the way its domain objects are constructed (“functional” decomposition)\, or by the way they are destructed (“object-oriented” decomposition)? We argue that programming languages should not force one of these decompositions on the programmer\; rather\, a programming language should support both ways of decomposing a program in a symmetric way\, with an easy translation between these decompositions. However\, current programming languages are usually not symmetric and hence make it unnecessarily hard to switch the decomposition. \nWe propose a language that is symmetric in this regard and allows a fully automatic translation between “functional” and “object-oriented” decomposition. We present a language with algebraic data types and pattern matching for “functional” decomposition and codata types and copattern matching for “object-oriented” decomposition\, together with a bijective translation that turns a data type into a codata type (“destructorization”) or vice versa (“constructorization”). We present the first symmetric programming language with support for local (co)pattern matching\, which includes local anonymous function or object definitions\, that allows an automatic translation as described above. We also present the first mechanical formalization of such a language and prove i) that the type system is sound\, that the translations between data and codata types are ii) type-preserving\, iii) behavior-preserving and iv) inverses of each other. We also extract a mechanically verified implementation from our formalization and have implemented an IDE with direct support for these translations.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T114500Z
DTEND:20200123T120730Z
DTSTAMP:20191226T230630Z
UID:3978e8be-c735-4fa9-b129-f15e4c3e06aa@conf.researchr.org
CREATED:20191127T180949Z
SUMMARY:[POPL Research Papers] Fast\, Sound\, and Effectively Complete Dynamic Race Prediction - Andreas Pavlogiannis
DESCRIPTION:Writing concurrent programs is highly error-prone due to the nondeterminism in interprocess communication. The most reliable indicators of errors in concurrency are data races\, which are accesses to a shared resource that can be executed concurrently. We study the problem of predicting data races in lock-based concurrent programs. The input consists of a concurrent trace t\, and the task is to determine all pairs of events of t that constitute a data race. The problem lies at the heart of concurrent verification and has been extensively studied for over three decades. However\, existing polynomial-time sound techniques are highly incomplete and can miss simple races. \nIn this work we develop M2: a new polynomial-time algorithm for this problem\, which has no false positives. In addition\, our algorithm is complete for input traces that consist of two processes\, i.e.\, it provably detects all races in the trace. We also develop sufficient criteria for detecting completeness dynamically in cases of more than two processes. We make an experimental evaluation of our algorithm on a challenging set of benchmarks taken from recent literature on the topic. Our algorithm soundly reports hundreds of real races\, many of which are missed by existing methods. In addition\, using our dynamic completeness criteria\, M2 concludes that it has detected all races in the benchmark set\, hence the reports are both sound and complete. Finally\, its running times are comparable\, and often smaller than the theoretically fastest\, yet highly incomplete\, existing methods. To our knowledge\, M2 is the first sound algorithm that achieves such a level of performance on both running time and completeness of the reported races.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T120730Z
DTEND:20200123T123000Z
DTSTAMP:20191226T230630Z
UID:cc57d4fa-c87b-4632-8222-450b84313191@conf.researchr.org
CREATED:20191127T180949Z
SUMMARY:[POPL Research Papers] Detecting Floating-Point Errors via Atomic Conditions - Daming Zou\, Muhan Zeng\, Yingfei Xiong\, Zhoulai Fu\, Lu Zhang\, Zhendong Su
DESCRIPTION:This paper tackles the important\, difficult problem of detecting program inputs that trigger large floating-point errors in numerical code. It introduces a novel\, principled dynamic analysis that leverages the mathematically rigorously analyzed condition numbers for atomic numerical operations\, which we call atomic conditions\, to effectively guide the search for large floating-point errors. Compared with existing approaches\, our work based on atomic conditions has several distinctive benefits: (1) it does not rely on high-precision implementations to act as approximate oracles\, which are difficult to obtain in general and computationally costly\; and (2) atomic conditions provide accurate\, modular search guidance. These benefits in combination lead to a highly effective approach that detects more significant errors in real-world code (e.g.\, widely-used numerical library functions) and achieves several orders of speedups over the state-of-the-art\, thus making error analysis significantly more practical. We expect the methodology and principles behind our approach to benefit other floating-point program analysis tasks such as debugging\, repair and synthesis. To facilitate the reproduction of our work\, we have made our implementation\, evaluation data and results publicly available on GitHub at https://github.com/FP-Analysis/atomic-condition.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T123000Z
DTEND:20200123T140000Z
DTSTAMP:20191226T230630Z
UID:27b0f307-5fe7-494b-b279-1989e8b3e1c5@conf.researchr.org
CREATED:20191128T064013Z
SUMMARY:[POPL Catering] Lunch
DESCRIPTION:Lunch
LOCATION:Lunch Room -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191128T065511Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T140000Z
DTEND:20200123T142140Z
DTSTAMP:20191226T230630Z
UID:1e66b8a5-9378-4c72-b881-77a86af1a22b@conf.researchr.org
CREATED:20191127T181439Z
SUMMARY:[POPL Research Papers] Abstract Extensionality: On the Properties of Incomplete Abstract Interpretations - Roberto Bruni\, Roberto Giacobazzi\, Roberta Gori\, Isabel Garcia-Contreras\, Dusko Pavlovic
DESCRIPTION:In this paper we generalize the notion of extensional (functional) equivalence of programs to abstract equivalences induced by abstract interpretations. The standard notion of extensional equivalence is recovered as the special case\, induced by the concrete interpretation. Some properties of the extensional equivalence\, such as the one spelled out in Rice’s theorem\, lift to the abstract equivalences in suitably generalized forms. On the other hand\, the generalized framework gives rise to interesting and important new properties\, and allows refined\, non-extensional analyses. In particular\, since programs turn out to be extensionally equivalent if and only if they are equivalent just for the concrete interpretation\, it follows that any non-trivial abstract interpretation uncovers some intensional aspect of programs. This striking result is also effective\, in the sense that it allows constructing\, for any non-trivial abstraction\, a pair of programs that are extensionally equivalent\, but have different abstract semantics. The construction is based on the fact that abstract interpretations are always sound\, but that they can be made incomplete through suitable code transformations. To construct these transformations\, we introduce a novel technique for building incompleteness cliques of extensionally equivalent yet abstractly distinguishable programs: they are built together with abstract interpretations that produce false alarms. While programs are forced into incompleteness cliques using both control-flow and data-flow transformations\, the main result follows from limitations of data-flow transformations with respect to control-flow ones. A further consequence is that the class of incomplete programs for a non-trivial abstraction is Turing complete. The obtained results also shed a new light on the relation between the techniques of code obfuscation and the precision in program analysis.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T035308Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T142140Z
DTEND:20200123T144320Z
DTSTAMP:20191226T230630Z
UID:578c760e-a543-4716-97fc-22910360d8c1@conf.researchr.org
CREATED:20191127T181439Z
SUMMARY:[POPL Research Papers] Abstract Interpretation of Distributed Network Control Planes - Ryan Beckett\, Aarti Gupta\, Ratul Mahajan\, David Walker
DESCRIPTION:The control plane of most computer networks runs distributed routing protocols that determine if and how traffic is forwarded. Errors in the configuration of network control planes frequently knock down critical online services\, leading to economic damage for service providers and significant hardship for users. Validation via ahead-of-time simulation can help find configuration errors but such techniques are expensive or even intractable for large industrial networks. We explore the use of abstract interpretation to address this fundamental scaling challenge and find that the right abstractions can reduce the asymptotic complexity of network simulation. Based on this observation\, we build a tool called ShapeShifter for reachability analysis. On a suite of 127 production networks from a large cloud provider\, ShapeShifter provides an asymptotic improvement in runtime and memory over the state-of-the-art simulator. These gains come with a minimal loss in precision. Our abstract analysis accurately predicts reachability for all destinations for 95% of the networks and for most destinations for the remaining 5%. We also find that abstract interpretation of network control planes not only speeds up existing analyses but also facilitates new kinds of analyses. We illustrate this advantage through a new destination “hijacking” analysis for the border gateway protocol (BGP)\, the globally-deployed routing protocol.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T035321Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T144320Z
DTEND:20200123T150500Z
DTSTAMP:20191226T230630Z
UID:749b78ee-f62e-4e59-b6b0-006218779315@conf.researchr.org
CREATED:20191127T181439Z
SUMMARY:[POPL Research Papers] Deterministic Parallel Fixpoint Computation - Sung Kook Kim\, Arnaud J. Venet\, Aditya V. Thakur
DESCRIPTION:Abstract interpretation is a general framework for expressing static program analyses. It reduces the problem of extracting properties of a program to computing an approximation of the least fixpoint of a system of equations. The de facto approach for computing an approximation of this fixpoint uses a sequential algorithm based on weak topological order (WTO). This paper presents a deterministic parallel algorithm for fixpoint computation by introducing the notion of weak partial order (WPO). We present an algorithm for constructing a WPO in almost-linear time. Finally\, we describe PIKOS\, our deterministic parallel abstract interpreter\, which extends the sequential abstract interpreter IKOS. We evaluate the performance and scalability of PIKOS on a suite of 1017 C programs. When using 4 cores\, PIKOS achieves an average speedup of 2.06x over IKOS\, with a maximum speedup of 3.63x. When using 16 cores\, PIKOS achieves a maximum speedup of 10.97x.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T140000Z
DTEND:20200123T153000Z
DTSTAMP:20191226T230630Z
UID:29a8f99d-d987-4950-a72b-31c3581d3cda@conf.researchr.org
CREATED:20191218T015525Z
SUMMARY:[POPL Student Research Competition] SRC Finalists Presentations
DESCRIPTION:
LOCATION:SRC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191218T015525Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T140000Z
DTEND:20200123T142140Z
DTSTAMP:20191226T230630Z
UID:63ef4c35-55ed-49cf-bf55-36cb8965696d@conf.researchr.org
CREATED:20191127T181246Z
SUMMARY:[POPL Research Papers] Undecidability of D<: and Its Decidable Fragments - Jason Z.S. Hu\, Ondřej Lhoták
DESCRIPTION:Dependent Object Types (DOT) is a calculus with path dependent types\, intersection types\, and object self-references\, which serves as the core calculus of Scala 3. Although the calculus has been proven sound\, it remains open whether type checking in DOT is decidable. In this paper\, we establish undecidability proofs of type checking and subtyping of D&lt\;:\, a syntactic subset of DOT. It turns out that even for D&lt\;:\, undecidability is surprisingly difficult to show\, as evidenced by counterexamples for past attempts. To prove undecidability\, we discover an equivalent definition of the D&lt\;: subtyping rules in normal form. Besides being easier to reason about\, this definition makes the phenomenon of bad bounds explicit as a single inference rule. After removing this rule\, we discover two decidable fragments of D&lt\;: subtyping and identify algorithms to decide them. We prove soundness and completeness of the algorithms with respect to the fragments\, and we prove that the algorithms terminate. Our proofs are mechanized in a combination of Coq and Agda.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T142140Z
DTEND:20200123T144320Z
DTSTAMP:20191226T230630Z
UID:148bf20d-6fc9-4674-8d66-180ba19e06e6@conf.researchr.org
CREATED:20191127T181246Z
SUMMARY:[POPL Research Papers] Decidable Subtyping for Path Dependent Types - Julian Mackay\, Alex Potanin\, Jonathan Aldrich\, Lindsay Groves
DESCRIPTION:Path dependent types have long served as an expressive component of the Scala programming language. They allow for the modelling of both bounded polymorphism and a degree of nominal subtyping. Nominality in turn provides the ability to capture first class modules. Thus a single language feature gives rise to a rich array of expressiveness. Recent work has proven path dependent types sound in the presence of both intersection and recursive types\, but unfortunately typing remains undecidable\, posing problems for programmers who rely on the results of type checkers. The Wyvern programming language is an object oriented language with path dependent types\, recursive types and first class modules. In this paper we define two variants of Wyvern that feature decidable typing\, along with machine checked proofs of decidability. Despite the restrictions\, our approaches retain the ability to encode the parameteric polymorphism of Java generics along with many idioms of the Scala module system.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T144320Z
DTEND:20200123T150500Z
DTSTAMP:20191226T230630Z
UID:ff3be797-3825-4c6d-97c5-5d445327c979@conf.researchr.org
CREATED:20191127T181246Z
SUMMARY:[POPL Research Papers] Dependent Type Systems as Macros - Stephen Chang\, Michael Ballantyne\, Milo Turner\, William J. Bowman
DESCRIPTION:We present Turnstile+\, a high-level\, macros-based metaDSL for building dependently typed languages. \nWith it\, programmers may rapidly prototype and iterate on the design of new dependently typed features and extensions. \nOr they may create entirely new DSLs whose dependent type “power” is tailored to a specific domain. \nOur framework’s support of language-oriented programming also makes it suitable for experimenting with systems of interacting components\, e.g.\, a proof assistant and its companion DSLs. \nThis paper explains the implementation details of Turnstile+\, as well as how it may be used to create a wide-variety of dependently typed languages\, from a lightweight one with indexed types\, to a full spectrum proof assistant\, complete with a tactic system and extensions for features like sized types and SMT interaction.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T153500Z
DTEND:20200123T155640Z
DTSTAMP:20191226T230630Z
UID:403bb6d1-d9f6-4dd5-b00a-e13dd2f7b3ab@conf.researchr.org
CREATED:20191127T181817Z
SUMMARY:[POPL Research Papers] A Language for Probabilistically Oblivious Computation - David Darais\, Ian Sweet\, Chang Liu\, Michael Hicks
DESCRIPTION:An oblivious computation is one that is free of direct and indirect information leaks\, e.g.\, due to observable differences in timing and memory access patterns. This paper presents λobliv\, a core language whose type system enforces obliviousness. Prior work on type-enforced oblivious computation has focused on deterministic programs. λobliv is new in its consideration of programs that implement probabilistic algorithms\, such as those involved in cryptography. λobliv employs a substructural type system and a novel notion of probability region to ensure that information is not leaked via the observed distribution of visible events. Probability regions support reasoning about probabilistic correlation and independence between values\, and our use of probability regions is motivated by a source of unsoundness that we discovered in the type system of ObliVM\, a language for implementing state of the art oblivious algorithms. We prove that λobliv’s type system enforces obliviousness and show that it is expressive enough to typecheck advanced tree-based oblivious RAMs.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T035031Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T155640Z
DTEND:20200123T161820Z
DTSTAMP:20191226T230630Z
UID:35dc9003-30dc-4a20-8898-a6b059e0cc6a@conf.researchr.org
CREATED:20191127T181817Z
SUMMARY:[POPL Research Papers] PλωNK: Functional Probabilistic NetKAT - Alexander Vandenbroucke\, Tom Schrijvers
DESCRIPTION:This work presents PλωNK\, a functional probabilistic network programming language that extends Probabilistic NetKAT (PNK). Like PNK\, it enables probabilistic modelling of network behaviour\, by providing probabilistic choice and infinite iteration (to simulate looping network packets). Yet\, unlike PNK\, it also offers abstraction and higher-order functions to make programming much more convenient. \nThe formalisation of PλωNK is challenging for two reasons: Firstly\, network programming induces multiple side effects (in particular\, parallelism and probabilistic choice) which need to be carefully controlled in a functional setting. Our system uses an explicit syntax for thunks and sequencing which makes the interplay of these effects explicit. Secondly\, measure theory\, the standard domain for formalisations of (continuous) probablistic languages\, does not admit higher-order functions. We address this by leveraging ω-Quasi Borel Spaces (ωQBSes)\, a recent advancement in the domain theory of probabilistic programming languages. \nWe believe that our work is not only useful for bringing abstraction to PNK\, but that—as part of our contribution—we have developed the meta-theory for a probabilistic language that combines advanced features like higher-order functions\, iteration and parallelism\, which may inform similar meta-theoretic efforts.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T161820Z
DTEND:20200123T164000Z
DTSTAMP:20191226T230630Z
UID:f96adae2-c079-40f5-a5db-5e2b0c7e37c4@conf.researchr.org
CREATED:20191127T181817Z
SUMMARY:[POPL Research Papers] Optimal Approximate Sampling From Discrete Probability Distributions - Feras Saad\, Cameron Freer\, Martin Rinard\, Vikash Mansinghka
DESCRIPTION:This paper addresses a fundamental problem in random variate generation: given access to a random source that emits a stream of independent fair bits\, what is the most accurate and entropy-efficient algorithm for sampling from a discrete probability distribution (p₁\, …\, pₙ)\, where the output distribution (p̂₁\, …\, p̂ₙ) of the sampling algorithm can be specified with a given level of bit precision? We present a theoretical framework for formulating this problem and provide new techniques for finding sampling algorithms that are optimal both statistically (in the sense of sampling accuracy) and information-theoretically (in the sense of entropy consumption). We leverage these results to build a system that\, for a broad family of measures of statistical accuracy\, delivers a sampling algorithm whose expected entropy usage is minimal among those that induce the same distribution (i.e.\, is “entropy-optimal”) and whose output distribution (p̂₁\, …\, p̂ₙ) is a closest approximation to the target distribution (p₁\, …\, pₙ) among all entropy-optimal sampling algorithms that operate within the specified precision budget. This optimal approximate sampler is also a closer approximation than any (possibly entropy-suboptimal) sampler that consumes a bounded amount of entropy with the specified precision\, a class which includes floating-point implementations of inversion sampling and related methods found in many standard software libraries. We evaluate the accuracy\, entropy consumption\, precision requirements\, and wall-clock runtime of our optimal approximate sampling algorithms on a broad set of probability distributions\, demonstrating the ways that they are superior to existing approximate samplers and establishing that they often consume significantly fewer resources than are needed by exact samplers.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T153500Z
DTEND:20200123T155640Z
DTSTAMP:20191226T230630Z
UID:2ad75350-be74-4dab-be4e-1df3a4bffea2@conf.researchr.org
CREATED:20191127T181645Z
SUMMARY:[POPL Research Papers] Deductive Verification with Ghost Monitors - Martin Clochard\, Claude Marché\, Andrei Paskevich
DESCRIPTION:We present a new approach to deductive program verification based on auxiliary programs called ghost monitors. This technique is useful when the syntactic structure of the target program is not well suited for verification\, for example\, when an essentially recursive algorithm is implemented in an iterative fashion. Our approach consists in implementing\, specifying\, and verifying an auxiliary program that monitors the execution of the target program\, in such a way that the correctness of the monitor entails the correctness of the target. The ghost monitor maintains the necessary data and invariants to facilitate the proof. It can be implemented and verified in any suitable framework\, which does not have to be related to the language of the target programs. This technique is also applicable when we want to establish relational properties between two target programs written in different languages and having different syntactic structure. \nWe then show how ghost monitors can be used to specify and prove fine-grained properties about the infinite behaviors of target programs. Since this cannot be easily done using existing verification frameworks\, we introduce a dedicated language for ghost monitors\, with an original construction to catch and handle divergent executions. The soundness of the underlying program logic is established using a particular flavor of transfinite games. This language and its soundness are formalized and mechanically checked.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T155640Z
DTEND:20200123T161820Z
DTSTAMP:20191226T230630Z
UID:484bbfda-5ea5-419c-8e40-3a078631154c@conf.researchr.org
CREATED:20191127T181645Z
SUMMARY:[POPL Research Papers] The Next 700 Relational Program Logics - Kenji Maillard\, Cătălin Hriţcu\, Exequiel Rivas\, Antoine Van Muylder
DESCRIPTION:We propose the first framework for defining relational program logics for arbitrary monadic effects. The framework is embedded within a relational dependent type theory and is highly expressive. At the semantic level\, we provide an algebraic characterization for relational specifications as a class of relative monads\, and link computations and specifications by introducing relational effect observations\, which map pairs of monadic computations to relational specifications in a way that respects the algebraic structure. For an arbitrary relational effect observation\, we generically define the core of a sound relational program logic\, and explain how to complete it to a full-fledged logic for the monadic effect at hand. We show that by instantiating our framework with state and unbounded iteration we can reconstruct a variant of Benton’s Relational Hoare Logic. Finally\, we identify and overcome conceptual challenges that prevented previous relational program logics from properly dealing with effects such as exceptions\, and are the first to provide a proper semantic foundation and a relational program logic for exceptions.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T161820Z
DTEND:20200123T164000Z
DTSTAMP:20191226T230630Z
UID:09d15489-b2f7-4ac2-9ab5-3c72a5825ae3@conf.researchr.org
CREATED:20191127T181645Z
SUMMARY:[POPL Research Papers] Incorrectness Logic - Peter O'Hearn
DESCRIPTION:Program correctness and incorrectness are two sides of the same coin. As a programmer\, even if you would like to have correctness\, you might find yourself spending most of your time reasoning about incorrectness. This includes informal reasoning that people do while looking at or thinking about their code\, as well as that supported by automated testing and static analysis tools. This paper describes a logic for program incorrectness which is\, in a sense\, the the other side of the coin to Hoare’s logic of correctness.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200123T165000Z
DTEND:20200123T180000Z
DTSTAMP:20191226T230630Z
UID:6b4a8e21-19b1-4dfd-94e3-4657db862ac2@conf.researchr.org
CREATED:20191127T182023Z
SUMMARY:[POPL Research Papers] Business Meeting & SRC Awards
DESCRIPTION:
LOCATION:POPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191221T091404Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T090000Z
DTEND:20200124T100000Z
DTSTAMP:20191226T230630Z
UID:a386e7d7-a525-4580-9976-ed009f270141@conf.researchr.org
CREATED:20191127T182108Z
SUMMARY:[POPL Research Papers] Probabilistic Programming - Hongseok Yang
DESCRIPTION:Probabilistic programming is the idea of developing a programming language for writing and reasoning about probabilistic models from machine learning and statistics. Such a language comes with the implementation of several generic inference algorithms that answer various queries about the models written in the language\, such as posterior inference and marginalisation. By providing these algorithms\, a probabilistic programming language enables scientists to focus on designing good models based on their domain knowledge\, instead of building effective inference engines for their models\, a task that typically requires expertise in machine learning\, statistics\, and systems. Even experts in machine learning and statistics may get benefited from such a probabilistic programming system because using the system they can easily explore highly advanced models. \nIn the past five years\, with colleagues from programming languages\, machine learning\, and probability theory\, I have worked on developing the semantic foundations\, efficient inference algorithms\, and static program analysis for probabilistic programming languages\, especially those that support expressive language features such as higher-order functions\, continuous distributions and general recursion. In this talk\, I will describe a few lessons that I have learnt so far.
LOCATION:POPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191221T085738Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T103000Z
DTEND:20200124T105140Z
DTSTAMP:20191226T230630Z
UID:629114f0-5ed7-4fbc-9fd4-454fd32fa2d3@conf.researchr.org
CREATED:20191127T182206Z
SUMMARY:[POPL Research Papers] Kind Inference for Datatypes - Ningning Xie\, Richard A. Eisenberg\, Bruno C. d. S. Oliveira
DESCRIPTION:In recent years\, languages like Haskell have seen a dramatic surge of new features that significantly extends the expressive power of their type systems. With these features\, the challenge of kind inference for datatype declarations has presented itself and become a worthy research problem on its own. \nThis paper studies kind inference for datatypes. Inspired by previous research on type-inference\, we offer declarative specifications for what datatype declarations should be accepted\, both for Haskell98 and for a more advanced system we call PolyKinds\, based on the extensions in modern Haskell\, including a limited form of dependent types. We believe these formulations to be novel and without precedent\, even for Haskell98. These specifications are complemented with implementable algorithmic versions. We study soundness\, completeness and the existence of principal kinds in these systems\, proving the properties where they hold. This work can serve as a guide both to language designers who wish to formalize their datatype declarations and also to implementors keen to have principled inference of principal types.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T105140Z
DTEND:20200124T111320Z
DTSTAMP:20191226T230630Z
UID:cd3a4210-bd29-4361-b4ad-4711e20f34a5@conf.researchr.org
CREATED:20191127T182206Z
SUMMARY:[POPL Research Papers] Partial Type Constructors: Or\, Making Ad Hoc Datatypes Less Ad Hoc - Mark Jones\, J. Garrett Morris\, Richard A. Eisenberg
DESCRIPTION:Functional programming languages assume that type constructors are total. Yet functional programmers know better: counterexamples range from container types that make limiting assumptions about their contents (e.g.\, requiring computable equality or ordering functions) to type families with defining equations only over certain choices of arguments. We present a language design and formal theory of partial type constructors\, capturing the domains of type constructors using qualified types. Our design is both simple and expressive: we support partial datatypes as first-class citizens (including as instances of parametric abstractions\, such as the Haskell Functor and Monad classes)\, and show a simple type elaboration algorithm that avoids placing undue annotation burden on programmers. We show that our type system rejects ill-defined types and can be compiled to a semantic model based on System F. Finally\, we have conducted an experimental analysis of a body of Haskell code\, using a proof-of-concept implementation of our system\; while there are cases where our system requires additional annotations\, these cases are rarely encountered in practical Haskell code.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T111320Z
DTEND:20200124T113500Z
DTSTAMP:20191226T230630Z
UID:9b6c8015-6b79-43d1-9d58-c0e1e7b53959@conf.researchr.org
CREATED:20191127T182206Z
SUMMARY:[POPL Research Papers] Pointer Life Cycle Types for Lock-Free Data Structures with Memory Reclamation - Roland Meyer\, Sebastian Wolff
DESCRIPTION:We consider the verification of lock-free data structures that manually manage their memory with the help of a safe memory reclamation (SMR) algorithm. Our first contribution is a type system that checks whether a program properly manages its memory. If the type check succeeds\, it is safe to ignore the SMR algorithm and consider the program under garbage collection. Intuitively\, our types track the protection of pointers as guaranteed by the SMR algorithm. There are two design decisions. The type system does not track any shape information\, which makes it extremely lightweight. Instead\, we rely on invariant annotations that postulate a protection by the SMR. To this end\, we introduce angels\, ghost variables with an angelic semantics. Moreover\, the SMR algorithm is not hard-coded but a parameter of the type system definition. To achieve this\, we rely on a recent specification language for SMR algorithms. Our second contribution is to automate the type inference and the invariant check. For the type inference\, we show a quadratic-time algorithm. For the invariant check\, we give a source-to-source translation that links our programs to off-the-shelf verification tools. It compiles away the angelic semantics. This allows us to infer appropriate annotations automatically in a guess-and-check manner. To demonstrate the effectiveness of our type-based verification approach\, we check linearizability for various list and set implementations from the literature with both hazard pointers and epoch-based memory reclamation. For many of the examples\, this is the first time they are verified automatically. For the ones where there is a competitor\, we obtain a speed-up of up to two orders of magnitude.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T103000Z
DTEND:20200124T105140Z
DTSTAMP:20191226T230630Z
UID:75e5326f-f93f-4b5d-b365-4f896a0fca0a@conf.researchr.org
CREATED:20191127T182332Z
SUMMARY:[POPL Research Papers] Virtual Timeline: A Formal Abstraction for Verifying Preemptive Schedulers with Temporal Isolation - Mengqi Liu\, Lionel Rieg\, Zhong Shao\, Ronghui Gu\, David Costanzo\, Jung-Eun Kim\, Man-Ki Yoon
DESCRIPTION:The reliability and security of safety-critical real-time systems are of utmost importance because the failure of these systems could incur severe consequences (loss of lives or failure of the mission). Such properties require strong isolation between components (given the ongoing trend of accommodating multiple components in a single platform)\, and they rely on enforcement mechanisms provided by the underlying operating system (OS) kernel. In addition to spatial isolation which is commonly provided by OS kernels to various extents\, it also requires temporal isolation\, that is\, properties on the schedule of one component (e.g.\, schedulability) are independent of behaviors of other components. The strict isolation between components relies critically on algorithmic properties of the concrete implementation of the scheduler\, such as timely provision of time slots\, obliviousness to preemption\, etc. However\, existing work either only reasons about an abstract model of the scheduler\, or proves properties of the scheduler implementation that are not rich enough to establish the isolation between different components. \nIn this paper\, we present a novel compositional framework for reasoning about algorithmic properties of the concrete implementation of preemptive schedulers. In particular\, we use virtual timeline\, a variant of the supply bound function used in the real-time scheduling analysis\, to specify and reason about the scheduling of each component in isolation. We show that the properties proved on this abstraction carry down to the generated assembly code of the OS kernel. Using this framework\, we successfully verify a real-time OS kernel\, which extends mCertiKOS\, a single-processor non-preemptive kernel\, with user-level preemption\, a verified timer interrupt handler and a verified real-time scheduler. We prove that in the absence of microarchitectural level timing channels\, this new kernel enjoys temporal and spatial isolation on top of the functional correctness guarantee. All the proofs are implemented in the Coq proof assistant.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T105140Z
DTEND:20200124T111320Z
DTSTAMP:20191226T230630Z
UID:6da54977-f8b5-4687-8fab-ee7a1ce56bb9@conf.researchr.org
CREATED:20191127T182332Z
SUMMARY:[POPL Research Papers] The High-Level Benefits of Low-Level Sandboxing - Michael Sammler\, Deepak Garg\, Derek Dreyer\, Tadeusz Litak
DESCRIPTION:Sandboxing is a common technique for allowing untrusted components to safely interact with trusted code. However\, previous work has only investigated the low-level memory isolation guarantees of sandboxing\, leaving open the question of what exactly are the end-to-end guarantees that sandboxing affords programmers. In this paper\, we fill this gap by exploring formally how sandboxing ensures the robust safety of trusted code\, i.e. safety in the presence of arbitrary untrusted code. First\, we present an idealized operational semantics for a language that combines trusted code with sandboxed untrusted code. Then\, we prove that safety properties of the trusted code (as enforced through a rich type system) are upheld in the presence of arbitrary untrusted code\, so long as all interactions with untrusted code occur at the “any” type (a type inhabited by all values). Finally\, to alleviate the burden of having to interact with untrusted code at the “any” type\, we develop a mechanism for automatically converting values between the “any” type and much richer types. All results of this paper are mechanized in the Coq proof assistant.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T111320Z
DTEND:20200124T113500Z
DTSTAMP:20191226T230630Z
UID:0e3bb0bb-54ef-408e-8b50-34c3c3bb2d8a@conf.researchr.org
CREATED:20191127T182332Z
SUMMARY:[POPL Research Papers] Interaction Trees: Representing Recursive and Impure Programs in Coq - Li-yao Xia\, Yannick Zakowski\, Paul He\, Chung-Kil Hur\, Gregory Malecha\, Benjamin C. Pierce\, Steve Zdancewic
DESCRIPTION:Interaction trees (ITrees) are a general-purpose data structure in Coq for representing the behaviors of recursive programs that interact with their environments. ITrees\, a coinductive variant of "free monads\,'' are built out of uninterpreted events and their continuations. They support compositional construction of interpreters from event handlers\, which give meaning to events by defining their semantics as monadic actions. They are expressive enough to represent impure and potentially nonterminating\, mutually recursive computations in Coq. And they give rise to a theory enabling equational reasoning\, up to weak bisimulation\, about ITrees and monadic computations built from them. In contrast to other approaches such as relationally specified operational semantics\, ITrees are executable via code extraction\, making them suitable for debugging\, testing\, and implementing software artifacts that are amenable to formal verification. \nWe have implemented ITrees and their associated theory as a Coq library\, which mechanizes classic domain- and category-theoretic results about program semantics\, iteration\, monadic structures\, and equational reasoning. Although the internals of the library make heavy use of coinductive proofs\, the interface hides these details so that clients can use and reason about ITrees without explicit use of Coq’s coinduction tactics. \nTo demonstrate the utility of our theory\, we prove the termination-sensitive correctness of a compiler from a simple imperative source language to an assembly-like target whose meanings are given as ITree-based denotational semantics. Unlike previous results using operational techniques\, this bisimulation proof follows straightforwardly by structural induction and elementary rewriting via an equational theory of combinators for control-flow graphs.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T114500Z
DTEND:20200124T120730Z
DTSTAMP:20191226T230630Z
UID:347935ed-4df7-4ac6-a9f9-32c25c827a61@conf.researchr.org
CREATED:20191127T182537Z
SUMMARY:[POPL Research Papers] Label-Dependent Session Types - Peter Thiemann\, Vasco T. Vasconcelos
DESCRIPTION:Session types have emerged as a typing discipline for communication protocols. Existing calculi with session types come equipped with many different primitives that combine communication with the introduction or elimination of the transmitted value. \nWe present a foundational session type calculus with a lightweight operational semantics. It fully decouples communication from the introduction and elimination of data and thus features a single communication reduction\, which acts as a rendezvous between senders and receivers. We achieve this decoupling by introducing label-dependent session types\, a minimalist value-dependent session type system with subtyping. The system is sufficiently powerful to simulate existing functional session type systems. Compared to such systems\, label-dependent session types place fewer restrictions on the code. We further introduce primitive recursion over natural numbers at the type level\, thus allowing to describe protocols whose behaviour depends on numbers exchanged in messages. An algorithmic type checking system is introduced and proved equivalent to its declarative counterpart. \nThe new calculus showcases a novel lightweight integration of dependent types and linear typing\, with has uses beyond session type systems.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T120730Z
DTEND:20200124T123000Z
DTSTAMP:20191226T230630Z
UID:459e8340-d64d-44fe-8aa7-f0b4de6d6081@conf.researchr.org
CREATED:20191127T182537Z
SUMMARY:[POPL Research Papers] Par means Parallel: Multiplicative Linear Logic Proofs as Concurrent Functional Programs - Federico Aschieri\, Francesco A. Genco
DESCRIPTION:Along the lines of Abramsky’s “Proofs-as-Processes” program\, we present an interpretation of multiplicative linear logic as typing system for concurrent functional programming. In particular\, we study a linear multiple-conclusion natural deduction system and show it is isomorphic to a simple and natural extension of λ-calculus with parallelism and communication primitives\, called λ_{par}. We shall prove that λ_{par} satisfies all the desirable properties for a typed programming language: subject reduction\, progress\, strong normalization and confluence.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T114500Z
DTEND:20200124T120730Z
DTSTAMP:20191226T230630Z
UID:159c3c5d-92b1-4056-9ed5-d30d8522d5bb@conf.researchr.org
CREATED:20191127T182704Z
SUMMARY:[POPL Research Papers] Proving Expected Sensitivity of Probabilistic Programs with Randomized Variable-Dependent Termination Time - Peixin Wang\, Hongfei Fu\, Krishnendu Chatterjee\, Yuxin Deng\, Ming Xu
DESCRIPTION:The notion of program sensitivity (aka Lipschitz continuity) specifies that changes in the program input result in proportional changes to the program output. For probabilistic programs the notion is naturally extended to expected sensitivity. A previous approach develops a nice relational program logic framework for proving expected sensitivity of probabilistic while loops\, where the number of iterations is fixed and bounded. In this work\, we consider probabilistic while loops where the number of iterations is not fixed\, but randomized and depends on the initial input values. We present a sound approach for proving expected sensitivity of such programs. Our sound approach is martingale-based and can be automated through existing martingale-synthesis algorithms. Furthermore\, our approach is compositional for sequential composition of while loops under a mild side condition. We demonstrate the effectiveness of our approach on several classical examples from Gambler’s Ruin\, stochastic hybrid systems and stochastic gradient descent. We also present experimental results showing that our automated approach can handle various probabilistic programs in the literature.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T120730Z
DTEND:20200124T123000Z
DTSTAMP:20191226T230630Z
UID:f9fa7d77-08cf-46e0-8b8e-887ef2b15ec5@conf.researchr.org
CREATED:20191127T182704Z
SUMMARY:[POPL Research Papers] Aiming Low Is Harder: Induction for Lower Bounds in Probabilistic Program Verification - Marcel Hark\, Benjamin Lucien Kaminski\, Jürgen Giesl\, Joost-Pieter Katoen
DESCRIPTION:We present a new inductive rule for verifying lower bounds on expected values of random variables after execution of probabilistic loops as well as on their expected runtimes. Our rule is simple in the sense that loop body semantics need to be applied only finitely often in order to verify that the candidates are indeed lower bounds. In particular\, it is not necessary to find the limit of a sequence as in many previous rules.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T035346Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T123000Z
DTEND:20200124T140000Z
DTSTAMP:20191226T230630Z
UID:27e53e09-4038-42b1-820e-b5af2cb54240@conf.researchr.org
CREATED:20191128T064104Z
SUMMARY:[POPL Catering] Lunch
DESCRIPTION:Lunch
LOCATION:Lunch Room -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191128T065511Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T140000Z
DTEND:20200124T142140Z
DTSTAMP:20191226T230630Z
UID:aff58d45-4406-4cd9-b249-38f83ced69dd@conf.researchr.org
CREATED:20191127T183022Z
SUMMARY:[POPL Research Papers] Stacked Borrows: An Aliasing Model for Rust - Ralf Jung\, Hoang-Hai Dang\, Jeehoon Kang\, Derek Dreyer
DESCRIPTION:Type systems are useful not just for the safety guarantees they provide\, but also for helping compilers generate more efficient code by simplifying important program analyses. In Rust\, the type system imposes a strict discipline on pointer aliasing\, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses. The problem is that Rust also supports unsafe code\, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline. To strike a balance between optimizations and unsafe code\, the language needs to provide a set of rules such that unsafe code authors can be sure\, if they are following these rules\, that the compiler will preserve the semantics of their code despite all the optimizations it is doing. \nIn this work\, we propose Stacked Borrows\, an operational semantics for memory accesses in Rust. Stacked Borrows defines an aliasing discipline and declares programs violating it to have undefined behavior\, meaning the compiler does not have to consider such programs when performing optimizations. We give formal proofs (mechanized in Coq) showing that this rules out enough programs to enable optimizations that reorder memory accesses around unknown code and function calls\, based solely on intraprocedural reasoning. We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T142140Z
DTEND:20200124T144320Z
DTSTAMP:20191226T230630Z
UID:3fe6e6e2-078b-414e-adff-e5557bd9c972@conf.researchr.org
CREATED:20191127T183022Z
SUMMARY:[POPL Research Papers] Executable Formal Semantics for the POSIX Shell - Michael Greenberg\, Austin J. Blatt
DESCRIPTION:The POSIX shell is a widely deployed\, powerful tool for managing computer systems. The shell is the expert’s control panel\, a necessary tool for configuring\, compiling\, installing\, maintaining\, and deploying systems. Even though it is powerful\, critical infrastructure\, the POSIX shell is maligned and misunderstood. Its power and its subtlety are a dangerous combination. \nWe define a formal\, mechanized\, executable small-step semantics for the POSIX shell\, which we call Smoosh. We compared Smoosh against seven other shells that aim for some measure of POSIX compliance (bash\, dash\, zsh\, OSH\, mksh\, ksh93\, and yash). Using three test suites—the POSIX test suite\, the Modernish test suite and shell diagnosis\, and a test suite of our own device—we found Smoosh’s semantics to be the most conformant to the POSIX standard. Modernish judges Smoosh to have the fewest bugs (just one\, from using dash’s parser) and no quirks. To show that our semantics is useful beyond yielding a conformant\, executable shell\, we also implemented a symbolic stepper to illuminate the subtle behavior of the shell. \nSmoosh will serve as a foundation for formal study of the POSIX shell\, supporting research on and development of new shells\, new tooling for shells\, and new shell designs.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T144320Z
DTEND:20200124T150500Z
DTSTAMP:20191226T230630Z
UID:602e6294-d6f2-4b1e-ad23-c9b2ad6af3b9@conf.researchr.org
CREATED:20191127T183022Z
SUMMARY:[POPL Research Papers] Disentanglement in Nested-Parallel Programs - Sam Westrick\, Rohan Yadav\, Matthew Fluet\, Umut Acar
DESCRIPTION:Nested parallelism has proved to be a popular approach for programming the rapidly expanding range of multicore computers. It allows programmers to express parallelism at a high level and relies on a run-time system and a scheduler to deliver efficiency and scalability. As a result\, many programming languages and extensions that support nested parallelism have been developed\, including in C/C++\, Java\, Haskell\, and ML. Yet\, writing efficient and scalable nested parallel programs remains challenging\, primarily due to difficult concurrency bugs arising from destructive updates or effects. For decades\, researchers have argued that functional programming can simplify writing parallel programs by allowing more control over effects but functional programs continue to underperform in comparison to parallel programs written in lower-level languages. The fundamental difficulty with functional languages is that they have high demand for memory\, and this demand only grows with parallelism. \nIn this paper\, we identify a memory property\, called disentanglement\, of race-free nested-parallel programs\, and propose memory management techniques for improved efficiency and scalability. Disentanglement allows for (destructive) effects as long as concurrently executing threads do not gain knowledge of the memory objects allocated by each other. We formally define disentanglement by considering an ML-like higher-order language with mutable references and presenting a dynamic semantics for it that enables reasoning about computation graphs of nested parallel programs. Based on this graph semantics\, we formalize a classic correctness property—determinacy race freedom—and prove that it implies disentanglement. This establishes that disentanglement applies to a relatively broad class of parallel programs. We then propose memory management techniques for nested-parallel programs that take advantage of disentanglement for improved efficiency and scalability. We show that these techniques are practical by extending the MLton compiler for Standard ML to support this form of nested parallelism. Our empirical evaluation shows that our techniques are efficient and scale well.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T140000Z
DTEND:20200124T142140Z
DTSTAMP:20191226T230630Z
UID:7d7b8a72-15b6-4126-9038-457475674685@conf.researchr.org
CREATED:20191127T182859Z
SUMMARY:[POPL Research Papers] Full Abstraction for the Quantum Lambda-Calculus - Pierre Clairambault\, Marc De Visme
DESCRIPTION:Quantum programming languages permit a hardware independent\, high-level description of quantum algorithms. In particular\, the quantum λ-calculus is a higher-order language with quantum primitives\, mixing quantum data and classical control. Giving satisfactory denotational semantics to the quantum λ-calculus is a challenging problem that has attracted significant interest. In the past few years\, both static (the quantum relational model) and dynamic (quantum game semantics) denotational models were given\, with matching computational adequacy results. However\, no model was known to be fully abstract. \nOur first contribution is a full abstraction result for the games model of the quantum λ-calculus. Full abstraction holds with respect to an observational quotient of strategies\, obtained by summing valuations of all states matching a given observable. Our proof method for full abstraction extends a technique recently introduced to prove full abstraction for probabilistic coherence spaces with respect to probabilistic PCF. \nOur second contribution is an interpretation-preserving functor from quantum games to the quantum relational model\, extending a long line of work on connecting static and dynamic denotational models. From this\, it follows that the quantum relational model is fully abstract as well. \nAltogether\, this gives a complete denotational landscape for the semantics of the quantum λ-calculus\, with static and dynamic models related by a clean functorial correspondence\, and both fully abstract.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T142140Z
DTEND:20200124T144320Z
DTSTAMP:20191226T230630Z
UID:3338b84f-bf14-4d02-bb63-71ff39fed460@conf.researchr.org
CREATED:20191127T182859Z
SUMMARY:[POPL Research Papers] Relational Proofs for Quantum Programs - Gilles Barthe\, Justin Hsu\, Mingsheng Ying\, Nengkun Yu\, Li Zhou
DESCRIPTION:Relational verification of quantum programs has many potential applications in quantum and post-quantum security and other domains. We propose a relational program logic for quantum programs. The interpretation of our logic is based on a quantum analogue of probabilistic couplings. We use our logic to verify non-trivial relational properties of quantum programs\, including uniformity for samples generated by the quantum Bernoulli factory\, reliability of quantum teleportation against noise (bit and phase flip)\, equivalence of quantum walks and security of quantum one-time pad.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T144320Z
DTEND:20200124T150500Z
DTSTAMP:20191226T230630Z
UID:a6b16c7c-ea06-4e1b-961b-e46edfacaa94@conf.researchr.org
CREATED:20191127T182859Z
SUMMARY:[POPL Research Papers] A Probabilistic Separation Logic - Gilles Barthe\, Justin Hsu\, Kevin Liao
DESCRIPTION:Probabilistic independence is a fundamental tool for reasoning about randomized programs. Independence describes the result of drawing a fresh random sample—a basic operation in all probabilistic languages—and greatly simplifies formal reasoning about collections of random samples. Nevertheless\, existing verification methods handle independence poorly\, if at all. \nIn this paper\, we propose a probabilistic separation logic where separation models probabilistic independence. We first give a new\, probabilistic model of the logic of bunched implications (BI)\, the logic of assertions in separation logic. Then\, we introduce a program logic based on these assertions and prove soundness of the proof system. We demonstrate our logic by verifying security properties of several cryptographic constructions\, including simple ORAM\, secure multi-party addition\, oblivious transfer\, and private information retrieval. Our logic is able to state and verify two different forms of the standard cryptographic security property\, while proofs work in terms of high-level properties like independence and uniformity.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T035236Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T153500Z
DTEND:20200124T155640Z
DTSTAMP:20191226T230630Z
UID:8848bee7-fc18-4150-b343-613f90f288fb@conf.researchr.org
CREATED:20191127T183203Z
SUMMARY:[POPL Research Papers] Taylor Subsumes Scott\, Berry\, Kahn and Plotkin - Davide Barbarossa\, Giulio Manzonetto
DESCRIPTION:The speculative ambition of replacing the old theory of program approximation based on syntactic continuity with the theory of resource consumption based on Taylor expansion and originating from the differential λ-calculus is nowadays at hand. Using this resource sensitive theory\, we provide simple proofs of important results in λ-calculus that are usually demonstrated by exploiting Scott’s continuity\, Berry’s stability or Kahn and Plotkin’s sequentiality theory. A paradigmatic example is given by the Perpendicular Lines Lemma for the Böhm tree semantics\, which is proved here simply by induction\, but relying on the main properties of resource approximants: strong normalization\, confluence and linearity.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T155640Z
DTEND:20200124T161820Z
DTSTAMP:20191226T230630Z
UID:53bdf924-41c2-4ed8-a2a7-e178df5f8758@conf.researchr.org
CREATED:20191127T183203Z
SUMMARY:[POPL Research Papers] Reduction Monads and Their Signatures - Benedikt Ahrens\, André Hirschowitz\, Ambroise Lafont\, Marco Maggesi
DESCRIPTION:In this work\, we study reduction monads\, which are essentially the same as monads relative to the free functor from sets into graphs. Reduction monads abstract two aspects of the lambda calculus: on the one hand\, in the monadic viewpoint\, it is an object equipped with a well-behaved substitution\; on the other hand\, in the graphical viewpoint\, it is an oriented graph whose vertices are terms and whose edges witness the reductions between two terms. \nWe study presentations of reduction monads. To this end\, we propose a notion of reduction signature. As usual\, such a signature plays the rôle of a virtual presentation\, and specifies arities for generating operations—possibly subject to equations—together with arities for generating reduction rules. For each such signature\, we define a category of models. Any model is\, in particular\, a reduction monad\, and\, in the spirit of Initial Semantics\, we define the reduction monad presented (or specified) by the given reduction signature to be\, if it exists\, the initial object of this category of models. \nOur main result identifies a class of reduction signatures which specify a reduction monad in the above sense. In particular\, the lambda calculus is naturally specified by such a signature.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T161820Z
DTEND:20200124T164000Z
DTSTAMP:20191226T230630Z
UID:15276b20-c1c3-46fb-b7ab-97f9e14da63b@conf.researchr.org
CREATED:20191127T183203Z
SUMMARY:[POPL Research Papers] Coq Coq Correct! Verification of Type Checking and Erasure for Coq\, in Coq - Matthieu Sozeau\, Simon Boulier\, Yannick Forster\, Nicolas Tabareau\, Théo Winterhalter
DESCRIPTION:Coq is built around a well-delimited kernel that perfoms typechecking for definitions in a variant of the Calculus of Inductive Constructions (CIC). Although the metatheory of CIC is very stable and reliable\, the correctness of its implementation in Coq is less clear. Indeed\, implementing an efficient type checker for CIC is a rather complex task\, and many parts of the code rely on implicit invariants which can easily be broken by further evolution of the code. Therefore\, on average\, one critical bug has been found every year in Coq. \nThis paper presents the first implementation of a type checker for the kernel of Coq (without the module system and template polymorphism)\, which is proven correct in Coq with respect to its formal specification and axiomatisation of part of its metatheory. Note that because of Gödel’s incompleteness theorem\, there is no hope to prove completely the correctness of the specification of Coq inside Coq (in particular strong normalisation or canonicity)\, but it is possible to prove the correctness of the implementation assuming the correctness of the specification\, thus moving from a trusted code base (TCB) to a trusted theory base (TTB) paradigm. \nOur work is based on the MetaCoq project which provides metaprogramming facilities to work with terms and declarations at the level of this kernel. Our type checker is based on the specification of the typing relation of the Polymorphic\, Cumulative Calculus of Inductive Constructions (PCUIC) at the basis of Coq and the verification of a relatively efficient and sound type-checker for it. In addition to the kernel implementation\, an essential feature of Coq is the so-called extraction: the production of executable code in functional languages from Coq definitions. We present a verified version of this subtle type-and-proof erasure step\, therefore enabling the verified extraction of a safe type-checker for Coq.
LOCATION:POPL-A -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T153500Z
DTEND:20200124T155640Z
DTSTAMP:20191226T230630Z
UID:241d6b95-05d9-4133-ad28-b3e4278cfe5e@conf.researchr.org
CREATED:20191127T183334Z
SUMMARY:[POPL Research Papers] Formal Verification of a Constant-Time Preserving C Compiler - Gilles Barthe\, Sandrine Blazy\, Benjamin Gregoire\, Rémi Hutin\, Vincent Laporte\, David Pichardie\, Alix Trieu
DESCRIPTION:Timing side-channels are arguably one of the main sources of vulnerabilities in cryptographic implementations. One effective mitigation against timing side-channels is to write programs that do not perform secret-dependent branches and memory accesses. This mitigation\, known as “cryptographic constant-time”\, is adopted by several popular cryptographic libraries. \nThis paper focuses on compilation of cryptographic constant-time programs\, and more specifically on the following question: is the code generated by a realistic compiler for a constant-time source program itself provably constant-time? Surprisingly\, we answer the question positively for a mildly modified version of the CompCert compiler\, a formally verified and moderately optimizing compiler for C. Concretely\, we modify the CompCert compiler to eliminate sources of potential leakage. Then\, we instrument the operational semantics of CompCert intermediate languages so as to be able to capture cryptographic constant-time. Finally\, we prove that the modified CompCert compiler preserves constant-time. Our mechanization maximizes reuse of the CompCert correctness proof\, through the use of new proof techniques for proving preservation of constant-time. These techniques achieve complementary trade-offs between generality and tractability of proof effort\, and are of independent interest.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T155640Z
DTEND:20200124T161820Z
DTSTAMP:20191226T230630Z
UID:3ce5dbc4-3034-4b64-9409-0e65f06e0d84@conf.researchr.org
CREATED:20191127T183334Z
SUMMARY:[POPL Research Papers] CompCertM: CompCert with C-Assembly Linking and Lightweight Modular Verification - Youngju Song\, Minki Cho\, Dongjoo Kim\, Yonghyun Kim\, Jeehoon Kang\, Chung-Kil Hur
DESCRIPTION:Supporting multi-language linking such as linking C and handwritten assembly modules in the verified compiler CompCert requires a more compositional verification technique than that used in CompCert just supporting separate compilation. The two extensions\, CompCertX and Compositional CompCert\, supporting multi-language linking take different approaches. The former simplifies the problem by imposing restrictions that the source modules should have no mutual dependence and be verified against certain well-behaved specifications. On the other hand\, the latter develops a new verification technique that directly solves the problem but at the expense of significantly increasing the verification cost. \nIn this paper\, we develop a novel lightweight verification technique\, called RUSC (Refinement Under Self-related Contexts)\, and demonstrate how RUSC can solve the problem without any restrictions but still with low verification overhead. For this\, we develop CompCertM\, a full extension of the latest version of CompCert supporting multi-language linking. Moreover\, we demonstrate the power of RUSC as a program verification technique by modularly verifying interesting programs consisting of C and handwritten assembly against their mathematical specifications.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200124T161820Z
DTEND:20200124T164000Z
DTSTAMP:20191226T230630Z
UID:7aea5cff-f1b5-4a34-ba7c-aa63da7819e9@conf.researchr.org
CREATED:20191127T183334Z
SUMMARY:[POPL Research Papers] Mechanized Semantics and Verified Compilation for a Dataflow Synchronous Language with Reset - Timothy Bourke\, Lélio Brun\, Marc Pouzet
DESCRIPTION:Specifications based on block diagrams and state machines are used to design control software\, especially in the certified development of safety-critical applications. Tools like SCADE Suite and Simulink/Stateflow are equipped with compilers to translate such specifications into executable code. They provide programming languages for composing functions over streams as typified by Dataflow Synchronous Languages like Lustre. \nRecent work builds on CompCert to specify and verify a compiler for the core of Lustre in the Coq Interactive Theorem Prover. It formally links the stream-based semantics of the source language to the sequential memory manipulations of generated assembly code. We extend this work to treat a primitive for resetting subsystems. Our contributions include new semantic rules that are suitable for mechanized reasoning\, a novel intermediate language for generating optimized code\, and proofs of correctness for the associated compilation passes.
LOCATION:POPL-B -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191223T040306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T090000Z
DTEND:20200125T093000Z
DTSTAMP:20191226T230630Z
UID:6dcfc936-4e7a-4d93-921c-d9f841e43ab8@conf.researchr.org
CREATED:20191210T092320Z
SUMMARY:[WGT] Gradual Typing as if Types Mattered - Ronald Garcia\, Éric Tanter
DESCRIPTION:Gradual typing is a principled approach to integrating static and dynamic type checking. To clarify what gradual typing means\, Siek and collaborators articulated criteria for gradually typed languages: essentially that type checking and execution must smoothly transition between the two type checking regimes. However\, these criteria say nothing about the relationship between the semantics of gradual and static types. This absence\, which can be ascribed to gradual typing’s tendency to focus on simple types\, becomes critical for advanced type disciplines\, where type \emph{safety} does not imply type \emph{soundness}. \nWe assert a semantic criterion for gradual types. To coherently blend static and dynamic checking of a particular type discipline\, a gradual type system must enforce the same invariants as those \emph{intended} by its purely-static counterpart. We justify this stance by considering several type disciplines\, highlighting key challenges and opportunities.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T093000Z
DTEND:20200125T100000Z
DTSTAMP:20191226T230630Z
UID:87ed34f8-8c5f-4d31-a066-6f0734578456@conf.researchr.org
CREATED:20191210T092320Z
SUMMARY:[WGT] Fully Abstract from Static to Gradual - Koen Jacobs\, Amin Timany\, Dominique Devriese
DESCRIPTION:What is a good gradual language? Siek et al. have previously proposed the refined criteria\, which specify certain guarantees about semantic correspondence and preservation of well-typedness and type-safety in the presence of untyped code. However\, because of their exclusive focus on syntactic properties\, they are not the whole story. Rich semantic properties like parametricity or non-interference\, which hold in the static language\, should also continue to hold upon gradualisation. \nIn this paper\, we investigate and argue for a new criterion previously hinted at by Devriese et al.: the embedding from the static to the gradual language should be fully abstract. We illustrate in a simple setting that the criterion is useful\; it can weed out an erroneous gradualisation that satisfies the refined criteria. We illustrate that it is realistic\, by giving a proof sketch for the natural gradualisation of $\operatorname{STLC}_\mu$.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T090000Z
DTEND:20200125T100000Z
DTSTAMP:20191226T230630Z
UID:3c6b2ace-7dca-46af-b571-0ed90e13044a@conf.researchr.org
CREATED:20191129T112401Z
SUMMARY:[CoqPL] SMTCoq: Safe and efficient automation in Coq (Keynote) - Chantal Keller
DESCRIPTION:SMTCoq is a plugin for the Coq interactive theorem prover to work in conjunction with automated theorem provers based on Boolean Satisfiability (SAT) and Satisfiability Modulo Theories (SMT)\, in an efficient and expressive way. First\, it allows one to formally establish\, in a proof assistant\, mathematical results relying on large combinatorial properties that require automatic Boolean reasoning. Second\, it provides a new Coq decision procedure that can be seen as a combination of existing decision procedures. \nTo achieve this objective with the same degree of safety as Coq itself\, SMTCoq communicates with SAT and SMT solvers that\, in addition to a yes/no answer\, can output traces of their internal proof search. The heart of SMTCoq is thus a certified\, efficient and modular checker for such traces expressed in a format that can encompass most aspects of SMT reasoning. Preprocessors - that need not be certified - for proof traces coming from the state-of-the-art SMT solvers CVC4 and veriT and SAT solver zChaff are implemented. \nIn this talk\, I will present the general ideas behind SMTCoq\, and focus on the recent features\, in particular the treatment of quantifiers.
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191215T204825Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T090000Z
DTEND:20200125T100000Z
DTSTAMP:20191226T230630Z
UID:eff0d239-a98a-4053-b7da-c41f7d173374@conf.researchr.org
CREATED:20191219T014830Z
SUMMARY:[PriSC]  Lucet: A Compiler and Runtime for High-Concurrency Low-Latency Sandboxing - Tyler McMullen
DESCRIPTION:
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T020045Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T103000Z
DTEND:20200125T110000Z
DTSTAMP:20191226T230630Z
UID:cd768223-8d1c-4bb7-b2e3-198a13df6996@conf.researchr.org
CREATED:20191129T111552Z
SUMMARY:[CoqPL] Deriving Instances with Dependent Types - Arthur Azevedo de Amorim
DESCRIPTION:We present Deriving\, a Coq library inspired by the analogous Haskell feature that simplifies the definition of class instances for inductive types. A few declarations suffice to define equality tests for a type or enumerate its elements\, and proofs of correctness are provided automatically. The library includes generic implementations of basic classes of the MathComp hierarchy (eqType\, choiceType\, countType and finType)\, and can be extended to other classes with user-level code.
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191204T154653Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T110000Z
DTEND:20200125T113000Z
DTSTAMP:20191226T230630Z
UID:519f2951-b0e6-46e8-9850-28731befc552@conf.researchr.org
CREATED:20191129T111552Z
SUMMARY:[CoqPL] The use of Coq for Common Criteria Evaluations - Yves Bertot\, Maxime Dénès\, Vincent Laporte\, Arnaud Fontaine\, Thomas Letan
DESCRIPTION:Coq has been successfully used to support CC formal analysis. The ANSSI and Inria have been collaborating on an authoritative document to introduce guidelines and rules for formal analyses supported by Coq\, in order to make these developments easier to read and evaluate. Our main motivation is to clarify our expectations regarding the use of Coq\, both for evaluators and developers involved in CC formal analyses. We believe CoqPL is an excellent opportunity to present the result of this work to the Coq community\, in the hope to start a discussion and gather feedback.
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191204T154921Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T113000Z
DTEND:20200125T120000Z
DTSTAMP:20191226T230630Z
UID:f9392208-a24c-4d41-ac04-c6b706143d50@conf.researchr.org
CREATED:20191129T111552Z
SUMMARY:[CoqPL] Verifying concurrent Go code in Coq with Goose - Tej Chajed\, Joseph Tassarotti\, M. Frans Kaashoek\, Nickolai Zeldovich
DESCRIPTION:This paper describes Goose\, a subset of Go that can be translated to a Coq model. The Coq model plugs into Iris for concurrency proofs\, giving an end-to-end system for writing and verifying concurrent systems. We have used Goose as part of our work on Perennial to verify a concurrent\, crash-safe mail server that gets good performance.
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191204T154957Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T120000Z
DTEND:20200125T123000Z
DTSTAMP:20191226T230630Z
UID:a5cab023-73d2-455b-9301-45c70b5ec83c@conf.researchr.org
CREATED:20191129T111552Z
SUMMARY:[CoqPL] A Tutorial on Equations - Matthieu Sozeau
DESCRIPTION:Equations is a plugin for the Coq proof assistant which provides a notation for defining programs by dependent pattern-matching and structural or well-founded recursion. It additionally derives useful high-level proof principles for demonstrating properties about them\, abstracting away from the implementation details of the function and its compiled form. The general design and implementation of the plug-in presented in [Sozeau and Mangin 2019] provides a robust and expressive function definition package as a definitional extension to the Coq kernel. At the core of the system is a new simplifier for dependent equalities based on an original handling of the no-confusion property of constructors. \nIn this tutorial talk\, we will present Eqations’ main features from the user point-of-view. This includes Eqations’ grammar for defining programs by dependent pattern-matching and well- founded recursion\, highlighting the treatment of Uniqueness of Identity Proofs and the facilities provided for the definition of well- founded or structurally recursive nested or mutually recursive functions. The package also includes supporting tactics for reason- ing a posteriori on Eqations definitions: an elimination principle tailored to the function definition and a set of rewrite rules cor- responding to its clauses\; both allow the development of concise and robust proof scripts involving the definitions. Finally\, the de- pendent pattern-matching engine at the core of Eqations is also made available in proof mode through a general purpose depen- dent pattern-matching tactic that is more expressive than current destruction tactics and intro-patterns (destruct\, inversion or Ssreflect’s elim and vanilla Coq or Ssreflect intro-patterns). The material presented here is part of lecture notes to be integrated in an upcoming volume of Software Foundations centered on the use of advanced tools in Coq.
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191204T154848Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T103000Z
DTEND:20200125T105400Z
DTSTAMP:20191226T230630Z
UID:54c51ee8-ea2d-4ea7-92f1-7354331c2873@conf.researchr.org
CREATED:20191219T015031Z
SUMMARY:[PriSC] Exorcising Spectres with Secure Compilers - Marco Patrignani\, Marco Guarnieri
DESCRIPTION:Speculative execution attacks like Spectre can be used to violate confidentiality in all modern general-purpose CPUs. Recently\, many compiler-level countermeasures have been proposed to mitigate the impact of Spectre-style attacks. However\, the correctness and security of these countermeasures has not been ascertained yet. Even worse\, while some of the existing countermeasures seem to be secure\, others are known to be insecure and produce vulnerable programs. \nIn this paper we report on our ongoing effort towards formally reasoning about the effectiveness of these countermeasures. For this\, we combine recent frameworks for reasoning about speculative information flows with a secure compilation theory telling that a compiler is secure when it preserves certain classes of (hyper)properties. We argue that Spectre-like attacks arise from violations of \emph{speculative non-interference}\, a non-interference-like property. By lifting speculative non-interference to the secure compilation setting\, we obtain a precise notion of security against Spectre-style attacks for compiler-level countermeasures. We believe that this criterion is the first step towards formally reasoning about the security of compiler-level countermeasures against Spectre-style attacks\, and we discuss our research plan.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T020045Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T105400Z
DTEND:20200125T111800Z
DTSTAMP:20191226T230630Z
UID:02332b1b-e5c7-4988-a94c-aa75c27ca86f@conf.researchr.org
CREATED:20191219T015031Z
SUMMARY:[PriSC] Trace-Relating Compiler Correctness and Secure Compilation - Carmine Abate\, Roberto Blanco\, Stefan Ciobaca\, Deepak Garg\, Cătălin Hriţcu\, Marco Patrignani\, Éric Tanter\, Jérémy Thibault
DESCRIPTION:Compiler correctness is\, in its simplest form\, defined as the inclusion of the set of traces of the compiled program into the set of traces of the original program\, which is equivalent to the preservation of all trace properties. Here traces collect\, for instance\, the externally observable events of each execution. This definition requires\, however\, the set of traces of the source and target languages to be exactly the same\, which is not the case when the languages are far apart or when observations are fine grained. To overcome this issue\, we study a generalized compiler correctness definition\, which uses source and target traces drawn from potentially different sets and connected by an arbitrary relation. We set out to understand what guarantees this generalized compiler correctness definition gives us when instantiated with a non-trivial relation on traces. When this trace relation is not equality\, it is no longer possible to preserve the trace properties of the source program unchanged. Instead\, we provide a generic characterization of the target trace property ensured by correctly compiling a program that satisfies a given source property\, and dually\, of the source trace property one is required to show in order to obtain a certain target property for the compiled code. We show that the same generalization also applies to a large class of secure compilation definitions\, which characterize the protection of a compiled program against linked adversarial code.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T020045Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T111800Z
DTEND:20200125T114200Z
DTSTAMP:20191226T230630Z
UID:725eee73-2093-4975-9e7a-31ef42d5eab0@conf.researchr.org
CREATED:20191219T015031Z
SUMMARY:[PriSC] Reconciling progress-insensitive noninterference and declassification - Johan Bay\, Aslan Askarov
DESCRIPTION:Practitioners of secure information flow often face a design challenge: what is the right semantic treatment of leaks via termination? On the one hand\, the potential harm of untrusted code calls for strong progress-sensitive security. On the other hand\, when the code is trusted to not aggressively exploit termination channels\, practical concerns\, such as permissiveness of the enforcement\, make a case for settling for weaker\, progress-insensitive security. This binary situation\, however\, provides no suitable middle point for systems that mix trusted and untrusted code. This work connects the two extremes by viewing progress-insensitivity as a particular form of declassification. Our novel semantic condition reconciles progress-insensitive security as a declassification bound on the so-called progress knowledge (in an otherwise progress-sensitive setting). We show how the new condition can be soundly enforced using a mostly standard information-flow monitor.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T020045Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T114200Z
DTEND:20200125T120600Z
DTSTAMP:20191226T230630Z
UID:7e0adcf9-c913-4df0-9222-a49624eca092@conf.researchr.org
CREATED:20191219T015031Z
SUMMARY:[PriSC] Hermes: Implementing Cryptography without Side-channels - Ken Friis Larsen\, Torben Mogensen\, Michael Kirkedal Thomsen
DESCRIPTION:We describe the reversible programming language Hermes\, which is designed for implementing encryption algorithms while eliminating certain classes of side-channels. Specifically\, every program written in Hermes is reversible: It can run equally well forwards and backwards. This means that you only write the encryption algorithm and get the decryption algorithm for free. Additionally\, Hermes ensures that all variables are cleared after use\, thus avoiding state information leakage and the language features a type system with secret and public types that ensures that code written in Hermes is both information flow secure and resistant to timing side channel attacks.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T020045Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T120600Z
DTEND:20200125T123000Z
DTSTAMP:20191226T230630Z
UID:cf21e54c-e82d-4c0d-aae0-d2ec184756d1@conf.researchr.org
CREATED:20191219T015031Z
SUMMARY:[PriSC] A CompCert Compiler that Preserves Cryptographic Constant-time - Sandrine Blazy\, Rémi Hutin\, David Pichardie
DESCRIPTION:Formally verified compilers guarantee the absence of correctness bugs introduced during the compilation\, but do not deal with other type of bugs\, such as security bugs. In our previous work\, we addressed the challenge of turning CompCert\, a formally verified compiler\, into a formally verified secure compiler. The notion of security we focused on is the preservation of “cryptographic constant-time”\, a popular side-channel protection against timing-based and cache-based attacks. However\, proving that CompCert is secure with respect to this property first required to modify several parts of the compiler. This extended abstract will focus on the changes we made to the CompCert compiler.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T020045Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T103000Z
DTEND:20200125T110000Z
DTSTAMP:20191226T230630Z
UID:06c89b6d-8315-48cf-ade8-60b41607df44@conf.researchr.org
CREATED:20191210T092643Z
SUMMARY:[WGT] Gradual Typing for Extensibility by Rows - Taro Sekiyama\, Atsushi Igarashi
DESCRIPTION:This work studies gradual typing for row types and row polymorphism. Key ingredients in this work are the \emph{dynamic row type}\, which represents a statically unknown part of a row\, and \emph{consistency for row types}\, which allows injecting static row types into the dynamic row type and\, conversely\, projecting the dynamic row type to any static row type. While consistency captures the behavior of the dynamic row type statically\, it makes the semantics of a gradually typed language incoherent when combined with row equivalence which identifies row types up to field reordering. To solve this problem\, we develop \emph{consistent equivalence}\, which characterizes composition of consistency and row equivalence. Using consistent equivalence\, we propose a polymorphic blame calculus $\text{F}^\rho_\text{C}$ for row types and row polymorphism. In $\text{F}^\rho_\text{C}$\, casts perform not only run-time checking with the dynamic row type but also field reordering in row types. To simplify our technical development for row polymorphism\, we adopt \emph{scoped} labels\, which are employed by the language Koka and are also emerging in the context of effect systems. We give the formal definition of $\text{F}^\rho_\text{C}$ with these technical developments and prove its type soundness. We also sketch the gradually typed surface language $\text{F}^\rho_\text{G}$ and type-preserving translation from $\text{F}^\rho_\text{G}$ to $\text{F}^\rho_\text{C}$ and discuss conservativity of $\text{F}^\rho_\text{G}$ over typing of a statically typed language with row types and row polymorphism.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T110000Z
DTEND:20200125T113000Z
DTSTAMP:20191226T230630Z
UID:2b12e422-8914-41ad-87fd-536fd87a038e@conf.researchr.org
CREATED:20191210T092643Z
SUMMARY:[WGT] Gradual Algebraic Data Types - Michael Greenberg\, Stefan Malewski\, Éric Tanter
DESCRIPTION:Algebraic data types are a distinctive feature of statically typed functional programming languages. Existing gradual typing systems support algebraic data types with set-theoretic approaches\, e.g.\, union and intersection types. What would it look like for a gradual typing system to support algebraic data types directly? We describe our early explorations of the design space of gradually typed algebraic data types using the Abstracting Gradual Typing methodology.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T113000Z
DTEND:20200125T120000Z
DTSTAMP:20191226T230630Z
UID:933fa8ee-9844-42e5-b4be-3ca99173060b@conf.researchr.org
CREATED:20191210T092643Z
SUMMARY:[WGT] Foreign Function Typing: Semantic Type Soundness for FFIs - Daniel Patterson\, Amal Ahmed
DESCRIPTION:In practice\, FFIs are implemented by translation to a target language and by conversions at the level of the target. We wish to establish type soundness in such a setting\, where there are two languages making foreign calls to one another. In particular\, we want a notion of \emph{convertibility}\, that a type $\tau_A$ from language $A$ is convertible to a type $\tau_B$ from language $B$\, which we will write $\tau_A \sim \tau_B$\, such that conversions between these types maintain type soundness (dynamically or statically) of the overall system. \nIn this paper\, we leverage the idea that sound FFIs are a generalization of sound gradual typing\, except unlike gradual typing\, FFIs mediate between languages \emph{without} a common underlying term language. We start with two languages and define type soundness in a manner inspired by the practical implementation strategy: that the languages will be translated to a common target. We do this using a realizability model\, that is\, by setting up a logical relation indexed by source types but inhabited by target terms that behave as dictated by the source types. The conversions $\tau_A \sim \tau_B$ that \emph{should} be allowed\, are the ones implemented by target-level translations that convert terms that semantically behave like $\tau_A$ to terms that semantically behave like $\tau_B$ (and vice versa). This means that the converted term must either produce a runtime cast failure or produce some term or value that behaves as $\tau_B$. With the notion of $\tau_A \sim \tau_B$ in hand\, we can type check a foreign function call\, and based on the semantics of $\tau_A \sim \tau_B$\, we can prove that typing the foreign function call is sound.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T120000Z
DTEND:20200125T123000Z
DTSTAMP:20191226T230630Z
UID:2a0838f0-5e6b-40ae-98a0-0d6903b8eec5@conf.researchr.org
CREATED:20191210T092643Z
SUMMARY:[WGT] Space-Efficient Monotonic References - Deyaaeldeen Almahallawi\, Jeremy G. Siek
DESCRIPTION:Integrating static typing and dynamic typing has been popular in academia and industry. Gradual typing is one approach to this integration that preserves type soundness by casting values at run-time. For higher order values such as functions and references\, a cast typically wraps them in a proxy that performs casts at use sites. This approach suffers from two problems: (1) chains of proxies can grow and consume unbounded space\, and (2) statically typed code regions need to check whether the value being used is proxied. Monotonic references [Siek et al. 2015c] solve the latter problem for mutable references by directly casting the heap cell instead of wrapping the reference in a proxy. In this paper we show that monotonic references can also solve the former problem. We present a space-efficient version of the semantics for monotonic references and prove an upper bound on space overhead. Furthermore\, the prior semantics for monotonic references involved storing cast expressions (not yet values) on the heap and it is not obvious how to implement this behavior efficiently in a compiler and run-time system. In our new semantics\, only values are written to the heap\, making the semantics straightforward to implement.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T123000Z
DTEND:20200125T140000Z
DTSTAMP:20191226T230630Z
UID:42829709-9143-4ae4-8c38-3ab02df06349@conf.researchr.org
CREATED:20191128T065511Z
SUMMARY:[POPL Catering] Lunch
DESCRIPTION:Lunch
LOCATION:Lunch Room -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191128T065511Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T140000Z
DTEND:20200125T143230Z
DTSTAMP:20191226T230630Z
UID:a6c5d7d6-0964-41a3-925a-3a150586349a@conf.researchr.org
CREATED:20191210T092352Z
SUMMARY:[WGT] Hypercoercions and a Framework for Equivalence of Cast Calculi - Kuang-Chen Lu\, Jeremy G. Siek\, Andre Kuhlenschmidt
DESCRIPTION:Designing a space-efficient cast representation that is good for both mechanized metatheory and implementation is challenging. Existing solutions (i.e. coercions\, threesomes\, and supercoercions) are good for one or the other. This paper presents a new cast representation\, named hypercoercions\, that is good for both. On the way to proving the correctness of hypercoercions\, this paper also makes progress on a general framework for proving the correctness of cast representations.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T143230Z
DTEND:20200125T150500Z
DTSTAMP:20191226T230630Z
UID:8f62d4f6-3c92-414c-9f0c-59a3bac09dd8@conf.researchr.org
CREATED:20191210T092352Z
SUMMARY:[WGT] Space-Efficient Gradual Typing in Coercion-Passing Style - Yuya Tsuda\, Atsushi Igarashi\, Tomoya Tabuchi
DESCRIPTION:Herman et al. (2007\, 2010) pointed out that the insertion of run-time checks into a gradually typed program could hamper tail-call optimization and\, as a result\, worsen the space complexity of the program. To address the problem\, they proposed a space-efficient coercion calculus\, which was subsequently improved by Garcia\, et al. (2009) and Siek et al. (2015). The semantics of these calculi involves eager composition of run-time checks expressed by coercions to prevent the size of a term from growing. However\, it relies also on a nonstandard reduction rule\, which does not seem easy to implement. In fact\, no compiler implementation of gradually typed languages fully supports the space-efficient semantics faithfully. \nIn this paper\, we study coercion-passing style\, which Herman et al. have already mentioned\, as a technique for straightforward space-efficient implementation of gradually typed languages. A program in coercion-passing style passes “the rest of run-time checks” around—just like continuation-passing style (CPS)\, in which “the rest of computation” has been passed around—and (unlike CPS) composes coercions eagerly. We give a formal coercion-passing translation from $\lambda$S by Siek et al. to $\lambda$S$_1$\, which is a new calculus of first-class coercions tailored for coercion-passing style\, and prove correctness of the translation. We also implement our coercion-passing style transformation for the Grift compiler developed by Kuhlenschmidt et al. and give a preliminary experimental result.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T140000Z
DTEND:20200125T150000Z
DTSTAMP:20191226T230630Z
UID:9f58b154-b4b4-4c82-a437-4ba3c369cf15@conf.researchr.org
CREATED:20191129T112209Z
SUMMARY:[CoqPL] Autosubst 2: Mechanising binders in Coq (Keynote) - Kathrin Stark
DESCRIPTION:Mechanising metatheory in the Coq proof assistant is often considered tedious as reasoning with binders without native support requires a lot of uninteresting technicalities. To relieve users from so-produced boilerplate\, the Autosubst compiler automates working with de Bruijn terms. Autosubst translates second-order HOAS specifications into the corresponding pure or scoped de Bruijn algebra: It hence generates a corresponding instantiation operation for parallel substitutions\, several equational substitution lemmas\, and tactics that among others implement automation for assumption-free substitution lemmas. Recent extensions of the Autosubst compiler include support for first-order syntax\, variadic syntax\, and modular syntax. \nIn this talk\, we outline the design and usage of Autosubst and in particular its recent extensions.
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191216T114924Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T140000Z
DTEND:20200125T142140Z
DTSTAMP:20191226T230630Z
UID:f725da86-0fef-4dc9-90b8-1d37d46a2e91@conf.researchr.org
CREATED:20191219T020011Z
SUMMARY:[PriSC] Exploits as Insecure Compilation - Jennifer Paykin\, Eric Mertens\, Mark Tullsen\, Luke Maurer\, Benoit Razet\, Alexander Bakst\, Scott Moore
DESCRIPTION:The study of secure compilation is typically focused on building compilers that do not introduce security vulner- abilities. Unfortunately\, the compilers used in practice are not secure\, and linking compiled components with untrusted contexts can introduce significant security vul- nerabilities. We propose repurposing the framework of secure compilation to study insecure compilers and the vulnerabilities they give rise to.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T020045Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T142400Z
DTEND:20200125T144800Z
DTSTAMP:20191226T230630Z
UID:6cd5244b-8556-4dfa-8096-1e27a5efe62f@conf.researchr.org
CREATED:20191219T020011Z
SUMMARY:[PriSC] Universal Composability is Secure Compilation - Marco Patrignani\, Riad S. Wahby\, Robert Künnemann
DESCRIPTION:Universal composability is a framework for the specification and analysis of cryptographic protocols with a strong compositionality guarantee: UC protocols are secure even when composed with other protocols. Secure compilation tells whether compiled programs are as secure as their source- level counterparts\, no matter what target-level code they interact with. These two disciplines are studied in isolation\, but we believe there is a deeper connection between them with benefits from both worlds to reap. This paper outlines the connection between universal composability and robust compilation\, the latest of secure compilation theories. We show how to read the universal composability theorem in terms of a robust compilation the- orem and vice-versa. This\, in turn\, shows which elements of one theory corresponds to which element in the other theory. We believe this is the first step towards understanding how can secure compilation theories be used in universal composability settings and vice-versa.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T020251Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T144800Z
DTEND:20200125T150500Z
DTSTAMP:20191226T230630Z
UID:0e9053bf-9abe-44f9-8c9e-8d8649905cc2@conf.researchr.org
CREATED:20191219T020011Z
SUMMARY:[PriSC] Short talks
DESCRIPTION:
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T020306Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T153500Z
DTEND:20200125T160700Z
DTSTAMP:20191226T230630Z
UID:c7255edb-b109-4dc8-a488-a2939b98bbce@conf.researchr.org
CREATED:20191210T093811Z
SUMMARY:[WGT] Gradual Verification of Recursive Heap Data Structures - Jenna Wise\, Johannes Bader\, Jonathan Aldrich\, Éric Tanter\, Joshua Sunshine
DESCRIPTION:Static verification tools for recursive heap data structures impose significant annotation burden on developers. This is true even when verifying a simple function that inserts an element at the end of a linked list. Gradual verification was introduced to allow developers to deal with this burden incrementally\, if at all. It draws from research on gradual typing to produce a verification system that supports imprecise specifications along a continuum. However\, current gradual verification technology can only support a simple first-order specification logic. This paper outlines work in progress on an extension to gradual verification that supports implicit dynamic frames and recursive abstract predicates using examples. This paper also highlights challenges and proposes solutions to verifying such examples.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T160700Z
DTEND:20200125T164000Z
DTSTAMP:20191226T230630Z
UID:82935562-7ead-4e87-83e4-ea3b62ec2b01@conf.researchr.org
CREATED:20191210T093811Z
SUMMARY:[WGT] Gradual Program Analysis - Samuel Estep\, Jenna Wise\, Jonathan Aldrich\, Éric Tanter\, Johannes Bader\, Joshua Sunshine
DESCRIPTION:The designers of static analyses used in industry often try to reduce the number of false positives reported by the analysis through increased engineering effort\, user-provided annotations\, and/or weaker soundness guarantees. To produce a static analysis with little engineering effort\, reduced false positives\, and strong soundness guarantees in a principled way\, we adapt the Abstracting Gradual Typing'' framework to the abstract-interpretation based program analysis setting. As a case study\, we take a simple static dataflow analysis that relies on user-provided annotations and has nullability lattice $N \sqsubset \top$ (where $N$ meansdefinitely not null'' and $\top$ means possibly null'') and extend it by adding $?$ as a third abstract value. The question mark explicitly representsoptimistic uncertainty'' in the analysis itself\, supporting a formal soundness property and the ``gradual guarantees'' laid out in the gradual typing literature. To evaluate our gradual null-pointer analysis\, we implement it as a Facebook Infer checker and compare it against the existing null checkers in Facebook Infer. A preliminary set of experiments show evidence of reduced false positives. We then generalize this example into a system that gradualizes any dataflow analysis in the same way: augmenting the lattice while retaining the properties that permit it to be used in the standard dataflow analysis fixpoint algorithm.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T164000Z
DTEND:20200125T165000Z
DTSTAMP:20191226T230630Z
UID:a6d284e7-faa9-4da9-a188-7011dd234d46@conf.researchr.org
CREATED:20191210T093811Z
SUMMARY:[WGT] Minibreak
DESCRIPTION:
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T165000Z
DTEND:20200125T172000Z
DTSTAMP:20191226T230630Z
UID:14216ddd-3d53-40f5-a371-a5fc77ba7c9e@conf.researchr.org
CREATED:20191210T093811Z
SUMMARY:[WGT] Blame tracking at higher fidelity - Jakub Zalewski\, James McKinna\, J. Garrett Morris\, Philip Wadler
DESCRIPTION:This paper introduces λdB\, a blame calculus with dependent types. It supports dependent functions\, predicate refinement at all types\, the dynamic type\, and full blame tracking. It is inspired by and extends previous work on hybrid types and Sage\, by Flanagan and others\; manifest contracts\, by Greenberg\, Pierce\, and Weyrich\; and blame calculus by Wadler and Findler. While previous work only allows refinement over base types\, λdB supports refinement over any type. We introduce novel techniques in order to prove blame safety for this language\, including a careful analysis that reduces open judgments on terms to closed ones on values\, and the idea of ‘subtyping with a witness’\, which fix flaws in the previous work of Wadler and Findler. These technical contributions mean that we can achieve a completely inductive (finitistic) account of the metatheory of our language\, and thereby avoid many of the subtle technical issues which have bedevilled earlier work in this area.
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T172000Z
DTEND:20200125T174500Z
DTSTAMP:20191226T230630Z
UID:dad899d3-7042-4527-8b5c-b6c0accf94d4@conf.researchr.org
CREATED:20191210T093811Z
SUMMARY:[WGT] Discussion on gradual typing and WGT21
DESCRIPTION:
LOCATION:WGT -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191213T114539Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T153500Z
DTEND:20200125T155900Z
DTSTAMP:20191226T230630Z
UID:03f59e29-c098-498e-b2a6-882fe1e214f9@conf.researchr.org
CREATED:20191219T084108Z
SUMMARY:[PriSC] Flexible Tag-based Policies for Compartmentalized C - Sean Anderson\, Andrew Tolmach\, Chris Chhak
DESCRIPTION:The principle of least privilege suggests that we can enhance the reliability and security of programs by dividing them into compartments that communicate via restricted interfaces. In an unsafe language such as C\, this can also isolate the impact of memory errors by restricting memory accesses across compartment boundaries. We are developing designs for C compartmentalization policies that can be efficiently implemented using tag-based hardware reference monitors. Our policies support dif- ferent cross-compartment interfaces\, ranging from a “share- nothing” model where compartments interact only by func- tion call and return passing scalars\, to a “share-anything” model in which compartments can exchange capabilities to access individual memory objects. Between these\, novel hy- brid models distinguish local and shareable objects. The tag policies vary in how much memory protection they provide\, from compartment-based fault isolation to full spatial and temporal memory safety for each object\, and each supports further restriction via mandatory access control. As an extensional characterization of the guarantees en- forced by these policies\, we propose a formal property called modularity defined in terms of a trace-based semantics for C. Modularity relates a tag policy to a filtering predicate on traces that accepts those traces whose cross-compartment events are allowed by a given interface. Intuitively\, modular- ity states that reasoning about equivalence in terms of cross- compartment behaviors assuming no interface violations is sound under the tag policy\; either equivalent programs remain equivalent\, or they fail-stop.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T084433Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T155900Z
DTEND:20200125T162300Z
DTSTAMP:20191226T230630Z
UID:aaecde22-3fa6-4510-b47e-9e8d14012e41@conf.researchr.org
CREATED:20191219T084108Z
SUMMARY:[PriSC] Mechanized Reasoning about a Capability Machine - Aina Linn Georges\, Alix Trieu\, Lars Birkedal
DESCRIPTION:Capability machines are promising targets for secure compilers since capabilities can be used to enforce abstractions that are usually expected for high-level languages\, such as well-bracketed control-flow (WBCF) and local state encapsulation (LSE). We present the first formalization of a capability machine that supports mechanized reasoning about deep semantic properties\, including WBCF and LSE. Our formalization is done in the Coq implementation of Iris\, a state-of-the-art concurrent higher-order separation logic\, and includes a formalization of the logical relation defined by Skorstensgaard et al. [ESOP2018]\, which can used to prove WBCF and LSE.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T084433Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T162300Z
DTEND:20200125T164700Z
DTSTAMP:20191226T230630Z
UID:60e901e4-7fdf-48ec-b95d-4bc1eeaf9299@conf.researchr.org
CREATED:20191219T084108Z
SUMMARY:[PriSC] Securing Interruptible Enclaves - Matteo Busi\, Job Noorman\, Jo Van Bulck\, Letterio Galletta\, Pierpaolo Degano\, Jan Tobias Mühlberg\, Frank Piessens
DESCRIPTION:Computer systems often provide hardware support for isolation mechanisms like privilege levels\, virtual memory\, or enclaved execution. Over the past few years\, several successful software-based side-channel attacks have been developed that break\, or at least significantly weaken\, the isolation that these mechanisms offer. Extending a processor with new (micro)architectural features brings a risk of enabling new such side-channel attacks. \nHere\, we summarize our work in extending a processor with new features \emph{without} weakening the security of the isolation mechanisms that it offers. \nFor that\, we first argue that a sensible formal criterion for proving the security of a processor extension is \emph{full abstraction}. Then\, we sketch the proof that our carefully designed extension of a microprocessor supports interruptibility of enclaved executions in a secure manner.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T084433Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T164700Z
DTEND:20200125T165700Z
DTSTAMP:20191226T230630Z
UID:a17144c6-3fba-4bbd-992b-1321683833c0@conf.researchr.org
CREATED:20191219T084108Z
SUMMARY:[PriSC] Mini-break
DESCRIPTION:
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T084433Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T165700Z
DTEND:20200125T172100Z
DTSTAMP:20191226T230630Z
UID:69456045-be1f-47ac-9374-f6b28bc57c72@conf.researchr.org
CREATED:20191219T084108Z
SUMMARY:[PriSC] WebAssembly as an Intermediate Language for Provably-Safe Software Sandboxing - Jay Bosamiya\, Benjamin Lim\, Bryan Parno
DESCRIPTION:Lightweight\, safe\, and fast execution of untrusted code is valuable in many contexts and can\, in theory\, be achieved via software fault isolation (SFI). Unfortunately\, technological and marketplace hurdles have prevent mass adoption of previous SFI technologies. We propose to use WebAssembly to overcome these hurdles. Conceretely\, we describe ongoing work on a formally verified sandboxing compiler\, from WebAssembly to native code\, towards this goal.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T084433Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T172100Z
DTEND:20200125T174500Z
DTSTAMP:20191226T230630Z
UID:22d02d26-7fb4-4b3c-9ad7-318d13099dcf@conf.researchr.org
CREATED:20191219T084108Z
SUMMARY:[PriSC] Memory Safety Preservation for WebAssembly - Marco Vassena\, Marco Patrignani
DESCRIPTION:WebAssembly (Wasm) is a next-generation portable compi- lation target for deploying applications written in high-level languages on the web. In order to protect their memory from untrusted code\, web browser engines confine the execution of compiled Wasm programs in a memory-safe sand- box. Unfortunately\, classic memory-safety vulnerabilities (e.g.\, buffer overflows and use-after-free) can still corrupt the memory within the sandbox and allow Wasm code to mount severe attacks. To prevent these attacks\, we study a class of secure compilers that eliminate (different kinds of) memory safety violations. Following a rigorous approach\, we discuss memory safety in terms of hypersafety properties\, which let us identify suitable secure compilation critera for memory-safety-preserving compilers. We conjecture that\, barring some restrictions at module boundaries\, the existing security mechanisms of Wasm may suffice to enforce memory-safety preservation\, in the short term. In the long term\, we observe that certain features proposed in the design of a memory-safe variant of Wasm could allow compilers to lift these restrictions and enforce relaxed forms of memory safety.
LOCATION:PriSC -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191219T084433Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T153500Z
DTEND:20200125T160500Z
DTSTAMP:20191226T230630Z
UID:bf98702a-db6b-4948-b7a5-2b6cf35b4f7e@conf.researchr.org
CREATED:20191129T113155Z
SUMMARY:[CoqPL] Towards Formally Verified Just-in-Time compilation - Aurèle Barrière\, Sandrine Blazy\, David Pichardie
DESCRIPTION:Just-in-Time compilation consists in interleaving program interpretation and compilation at run-time\, to achieve better performance than standard interpretation. While some of the execution time is spent compiling\, a JIT compiler can leverage run-time information to make speculative optimizations. These optimizations create optimized versions of functions given some assumptions. While static compilers have been the topic of many formal verification works\, few have tackled JIT compilation verification. We present our ongoing work about formal verification of a Just-in-Time compiler.
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191204T154939Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T160500Z
DTEND:20200125T163500Z
DTSTAMP:20191226T230630Z
UID:9b4f223c-c2d3-42b2-901c-bf58a4aca192@conf.researchr.org
CREATED:20191129T113155Z
SUMMARY:[CoqPL] A Coq Library of Undecidable Problems - Yannick Forster\, Dominique Larchey-Wendling\, Andrej Dudenhefner\, Edith Heiter\, Dominik Kirst\, Fabian Kunze\, Gert Smolka\, Simon Spies\, Dominik Wehr\, Maximilian Wuttke
DESCRIPTION:We propose a talk on our library of mechanised reductions to establish undecidability results in Coq. The library is a collaborative effort\, growing constantly and we are seeking more outside contributors willing to work on undecidability results in Coq.
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191204T154904Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T163500Z
DTEND:20200125T165000Z
DTSTAMP:20191226T230630Z
UID:c7cadfe2-99f8-4da2-8fd3-9c1c22c354f2@conf.researchr.org
CREATED:20191129T113155Z
SUMMARY:[CoqPL] Short break
DESCRIPTION:
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191129T113305Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20200125T165000Z
DTEND:20200125T173500Z
DTSTAMP:20191226T230630Z
UID:20407561-9623-40ad-b627-c0504ce92189@conf.researchr.org
CREATED:20191129T113155Z
SUMMARY:[CoqPL] Session with the Coq Development Team - Maxime Dénès\, Matthieu Sozeau
DESCRIPTION:
LOCATION:CoqPL -  614 Canal St, New Orleans, United States
LAST-MODIFIED:20191129T113446Z
END:VEVENT
END:VCALENDAR